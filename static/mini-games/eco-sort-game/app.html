<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Eco Sort: Atmospheric</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #header {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .score-box {
            font-size: 1.5rem;
            font-weight: bold;
        }

        #weather-info {
            font-size: 1rem;
            color: #ddd;
            text-transform: uppercase;
            margin-left: 20px;
        }

        #current-item-label {
            font-size: 1.2rem;
            color: #FFD700;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin-top: 10px;
            text-shadow: 1px 1px 2px black;
        }

        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            pointer-events: auto; /* Allow clicking */
            cursor: pointer; /* Show pointer to indicate clickable */
        }

        #instructions {
            font-size: 1.5rem;
            text-align: center;
            padding: 20px;
            border: 2px solid white;
            background: rgba(0,0,0,0.7);
            pointer-events: none; /* Let clicks pass to blocker */
        }

        #controls-hint {
            text-align: center;
            color: white;
            padding: 20px;
            font-size: 0.9rem;
            text-shadow: 1px 1px 2px black;
            opacity: 0.8;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: white;
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }
    </style>
</head>
<body>

    <div id="blocker">
        <div id="instructions">
            <span style="font-size: 2rem;">CLICK TO PLAY</span><br><br>
            WASD = Move<br>
            MOUSE = Look<br>
            LMB = Throw
        </div>
    </div>

    <div id="ui-layer">
        <div id="header">
            <div class="score-box">Score: <span id="score">0</span> <span id="weather-info"></span></div>
            <div id="current-item-label">Loading...</div>
        </div>
        <div id="feedback"></div>
        <div id="controls-hint">Aim for the correct bin</div>
    </div>
    <div id="crosshair"></div>

    <!-- Import Map for Modules -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const TRASH_TYPES = {
            PAPER: { id: 'paper', label: 'Paper', color: 0x2196F3 },   // Blue
            PLASTIC: { id: 'plastic', label: 'Plastic', color: 0xFFEB3B }, // Yellow
            GLASS: { id: 'glass', label: 'Glass', color: 0x4CAF50 },    // Green
            ORGANIC: { id: 'organic', label: 'Organic', color: 0x795548 } // Brown
        };

        const BIN_CONFIG = [
            { type: 'PAPER', x: -4.5 },
            { type: 'PLASTIC', x: -1.5 },
            { type: 'GLASS', x: 1.5 },
            { type: 'ORGANIC', x: 4.5 }
        ];

        // --- Weather Config ---
        const WEATHER_OPTS = ['CLEAR', 'RAIN', 'SNOW'];
        let currentWeather = 'CLEAR';
        let particles, particleSystem;

        // --- Globals ---
        let scene, camera, renderer, world, controls;
        let trashBody = null, trashMesh = null;
        let trajectoryLine;
        let currentTrashType = null;
        let isTrashThrown = false;
        let score = 0;
        let canThrow = true;
        
        // Auto-respawn logic
        let stationaryTimer = 0;
        let throwTimestamp = 0;

        // Movement Flags
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();

        // Lock state debounce
        let lastLockRequest = 0;

        // Materials
        let groundMat, binMat, trashPhysMat;

        init();
        animate();

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            
            // Random Weather Selection
            currentWeather = WEATHER_OPTS[Math.floor(Math.random() * WEATHER_OPTS.length)];
            setupWeather(currentWeather);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.8, 8); // Start further back
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            document.body.appendChild(renderer.domElement);

            // 2. Controls (Pointer Lock)
            controls = new PointerLockControls(camera, document.body);

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            // Robust Click Handler with Debounce
            blocker.addEventListener('click', function () {
                const now = Date.now();
                if (now - lastLockRequest < 1200) return; // Prevent rapid firing causing SecurityError
                lastLockRequest = now;
                
                controls.lock();
            });

            // Listen for Pointer Lock Errors to prevent freezing
            document.addEventListener('pointerlockerror', function() {
                console.warn("Pointer lock failed. Please try clicking again.");
                // Ensure blocker is visible if lock fails
                instructions.style.display = '';
                blocker.style.display = 'flex';
            });

            controls.addEventListener('lock', function () {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'flex';
                instructions.style.display = '';
            });

            scene.add(controls.getObject());

            // Key Listeners
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = true;
                        break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = false;
                        break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Click to throw
            document.addEventListener('mousedown', () => { // Changed to mousedown for better response
                if (controls.isLocked) {
                     if (!isTrashThrown) {
                        throwTrash();
                    }
                }
            });


            // 3. Lighting
            const ambientInt = currentWeather === 'CLEAR' ? 0.6 : 0.3;
            const ambientLight = new THREE.AmbientLight(0xffffff, ambientInt);
            scene.add(ambientLight);

            const dirInt = currentWeather === 'CLEAR' ? 1.2 : 0.6;
            const dirLight = new THREE.DirectionalLight(0xffffff, dirInt);
            dirLight.position.set(20, 30, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 40;
            dirLight.shadow.camera.bottom = -40;
            dirLight.shadow.camera.left = -40;
            dirLight.shadow.camera.right = 40;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 4. Physics World
            world = new CANNON.World();
            world.gravity.set(0, -15, 0); 
            world.solver.iterations = 10;

            // Physics Materials
            const defaultMaterial = new CANNON.Material('default');
            const trashMaterial = new CANNON.Material('trash');
            
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.4,
                restitution: 0.3
            });
            const trashContactMaterial = new CANNON.ContactMaterial(trashMaterial, defaultMaterial, {
                friction: 0.5,
                restitution: 0.1
            });
            
            world.addContactMaterial(defaultContactMaterial);
            world.addContactMaterial(trashContactMaterial);

            groundMat = defaultMaterial;
            binMat = defaultMaterial;
            trashPhysMat = trashMaterial;

            // 5. Create Environment
            createGround();
            createBins();
            createFence(); 
            createTrajectoryLine();
            createTrees();

            // 6. Initial Spawn
            spawnTrash();

            // 7. Events
            window.addEventListener('resize', onWindowResize);
        }

        // --- Weather System ---
        function setupWeather(type) {
            document.getElementById('weather-info').innerText = "| Weather: " + type;
            let skyColor, fogColor, fogNear, fogFar;

            if (type === 'CLEAR') {
                skyColor = 0x87CEEB;
                fogColor = 0x87CEEB;
                fogNear = 20;
                fogFar = 70;
            } else if (type === 'RAIN') {
                skyColor = 0x4a5b6c;
                fogColor = 0x4a5b6c;
                fogNear = 5;
                fogFar = 30;
                // Optimized count: 600 particles for better density without lag
                createPrecipitation(0xaaaaaa, 600, 0.6); 
            } else if (type === 'SNOW') {
                skyColor = 0xcadfe8;
                fogColor = 0xcadfe8;
                fogNear = 10;
                fogFar = 40;
                // Optimized count: 400 particles
                createPrecipitation(0xffffff, 400, 0.2); 
            }

            scene.background = new THREE.Color(skyColor);
            scene.fog = new THREE.Fog(fogColor, fogNear, fogFar);
        }

        function createPrecipitation(color, count, size) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 60;
                const y = Math.random() * 40; // Initial random spread 0-40
                const z = (Math.random() - 0.5) * 60;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: size,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function updateWeatherParticles(delta) {
            if (!particleSystem) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const fallSpeed = currentWeather === 'RAIN' ? 35 : 3; // Rain fast, Snow slow
            const wind = currentWeather === 'SNOW' ? 1 : 0;

            for (let i = 1; i < positions.length; i += 3) {
                // Y position (falling)
                positions[i] -= fallSpeed * delta;
                
                // X position (wind for snow)
                if (wind) positions[i-1] += Math.sin(Date.now() * 0.001 + i) * 0.02;

                // Reset if below ground
                if (positions[i] < 0) {
                    // FIX: Reset to a RANDOM height range to prevent "waves" or sheets of rain
                    // Spawns between y=30 and y=50
                    positions[i] = 30 + Math.random() * 20; 
                    
                    // Reset X/Z slightly randomly around camera to keep rain relevant
                    positions[i-1] = (Math.random() - 0.5) * 60 + camera.position.x; 
                    positions[i+1] = (Math.random() - 0.5) * 60 + camera.position.z;
                }
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        // --- Atmosphere: Fence ---
        function createFence() {
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.9 });
            const postGeo = new THREE.BoxGeometry(0.2, 1.5, 0.2);
            const railGeo = new THREE.BoxGeometry(2.2, 0.15, 0.05);
            
            // Helper to make a fence segment
            const createSegment = (x, z, rotY) => {
                const group = new THREE.Group();
                group.position.set(x, 0.75, z);
                group.rotation.y = rotY;

                // Post
                const post = new THREE.Mesh(postGeo, woodMat);
                post.castShadow = true;
                group.add(post);

                // Rails
                const rail1 = new THREE.Mesh(railGeo, woodMat);
                rail1.position.set(1, 0.3, 0);
                rail1.castShadow = true;
                group.add(rail1);

                const rail2 = new THREE.Mesh(railGeo, woodMat);
                rail2.position.set(1, -0.3, 0);
                rail2.castShadow = true;
                group.add(rail2);

                scene.add(group);

                // Simple Physics for Post
                const shape = new CANNON.Box(new CANNON.Vec3(0.1, 0.75, 0.1));
                const body = new CANNON.Body({ mass: 0, material: groundMat });
                body.addShape(shape);
                body.position.set(x, 0.75, z);
                world.addBody(body);
            };

            // Back Fence (Z = -4)
            // Width roughly -7 to 7
            for(let x = -7; x < 7; x += 2) {
                createSegment(x, -4, 0);
            }
            // Final post for back
            const endPost = new THREE.Mesh(postGeo, woodMat);
            endPost.position.set(7, 0.75, -4);
            endPost.castShadow = true;
            scene.add(endPost);

            // Left Side Fence (X = -7) from Z=-4 to Z=2
            for(let z = -4; z < 2; z += 2) {
                createSegment(-7, z, Math.PI / 2);
            }

            // Right Side Fence (X = 7) from Z=-4 to Z=2
            for(let z = -4; z < 2; z += 2) {
                createSegment(7, z, Math.PI / 2);
            }
        }

        // --- Atmosphere: Trees ---
        function createTrees() {
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32, roughness: 0.8 });
            if (currentWeather === 'SNOW') leavesMat.color.setHex(0xEEEEEE); // Snowy trees

            // Create 80 random trees
            for(let i = 0; i < 80; i++) {
                // Random position in a donut shape (avoid center)
                const angle = Math.random() * Math.PI * 2;
                const minRadius = 12; // Don't spawn close to bins
                const maxRadius = 50;
                const radius = minRadius + Math.random() * (maxRadius - minRadius);
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Random scale
                const scale = 1 + Math.random() * 1.5;

                const treeGroup = new THREE.Group();
                treeGroup.position.set(x, 0, z);

                // Trunk
                const trunkGeo = new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 1.5 * scale, 6);
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = (1.5 * scale) / 2;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                treeGroup.add(trunk);

                // Leaves (Two stacked cones)
                const coneGeo1 = new THREE.ConeGeometry(1.2 * scale, 2 * scale, 8);
                const leaves1 = new THREE.Mesh(coneGeo1, leavesMat);
                leaves1.position.y = (1.5 * scale) + 0.5 * scale;
                leaves1.castShadow = true;
                leaves1.receiveShadow = true;
                treeGroup.add(leaves1);

                const coneGeo2 = new THREE.ConeGeometry(0.9 * scale, 1.5 * scale, 8);
                const leaves2 = new THREE.Mesh(coneGeo2, leavesMat);
                leaves2.position.y = (1.5 * scale) + 1.2 * scale;
                leaves2.castShadow = true;
                leaves2.receiveShadow = true;
                treeGroup.add(leaves2);

                // Random rotation for variety
                treeGroup.rotation.y = Math.random() * Math.PI;
                // Slight tilt
                treeGroup.rotation.z = (Math.random() - 0.5) * 0.1;
                treeGroup.rotation.x = (Math.random() - 0.5) * 0.1;

                scene.add(treeGroup);
            }
        }

        function createTrajectoryLine() {
            const points = [];
            for(let i=0; i<40; i++) points.push(new THREE.Vector3(0,0,0));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 2,
                opacity: 0.6,
                transparent: true
            });
            trajectoryLine = new THREE.Line(geometry, material);
            scene.add(trajectoryLine);
        }

        function createGround() {
            // Visual
            const color = currentWeather === 'SNOW' ? 0xffffff : 0x558B2F;
            const geo = new THREE.PlaneGeometry(200, 200); // Larger ground for trees
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 1 }); 
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Physics
            const shape = new CANNON.Plane();
            const body = new CANNON.Body({ mass: 0, material: groundMat });
            body.addShape(shape);
            body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(body);
        }

        // --- Bin Creation Logic ---
        function createBins() {
            BIN_CONFIG.forEach(config => {
                const typeData = TRASH_TYPES[config.type];
                createBin(config.x, 0, -2, typeData.color, config.type);
            });
        }

        // Function to create Icon Textures based on Trash Type
        function createIconTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Background (White Plate)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 256, 256);
            
            // Border/Rim for relief look
            ctx.lineWidth = 12;
            ctx.strokeStyle = '#e0e0e0';
            ctx.strokeRect(0, 0, 256, 256);

            ctx.fillStyle = '#333333';
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Draw Icon centered
            const cx = 128;
            const cy = 128;

            if (type === 'PAPER') {
                // Document Icon
                ctx.beginPath();
                ctx.moveTo(80, 50);
                ctx.lineTo(140, 50);
                ctx.lineTo(180, 90);
                ctx.lineTo(180, 200);
                ctx.lineTo(80, 200);
                ctx.closePath();
                ctx.stroke();
                // Fold
                ctx.beginPath();
                ctx.moveTo(140, 50);
                ctx.lineTo(140, 90);
                ctx.lineTo(180, 90);
                ctx.stroke();
                // Lines
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(100, 120); ctx.lineTo(160, 120);
                ctx.moveTo(100, 150); ctx.lineTo(160, 150);
                ctx.moveTo(100, 180); ctx.lineTo(140, 180);
                ctx.stroke();

            } else if (type === 'PLASTIC') {
                // Plastic Bottle Icon
                ctx.beginPath();
                // Cap
                ctx.fillStyle = '#333';
                ctx.fillRect(113, 40, 30, 15);
                // Neck
                ctx.beginPath();
                ctx.moveTo(118, 55);
                ctx.lineTo(118, 80);
                ctx.quadraticCurveTo(118, 100, 90, 110);
                ctx.lineTo(90, 210);
                ctx.quadraticCurveTo(90, 220, 100, 220);
                ctx.lineTo(156, 220);
                ctx.quadraticCurveTo(166, 220, 166, 210);
                ctx.lineTo(166, 110);
                ctx.quadraticCurveTo(138, 100, 138, 80);
                ctx.lineTo(138, 55);
                ctx.stroke();
                // Label lines
                ctx.beginPath();
                ctx.moveTo(90, 140); ctx.lineTo(166, 140);
                ctx.moveTo(90, 170); ctx.lineTo(166, 170);
                ctx.stroke();

            } else if (type === 'GLASS') {
                // Wine Glass / Bottle Icon
                // Goblet
                ctx.beginPath();
                ctx.moveTo(88, 60);
                ctx.lineTo(168, 60); // Top
                ctx.quadraticCurveTo(168, 140, 128, 140); // Bowl right
                ctx.quadraticCurveTo(88, 140, 88, 60); // Bowl left
                ctx.stroke();
                // Stem
                ctx.beginPath();
                ctx.moveTo(128, 140);
                ctx.lineTo(128, 200);
                ctx.stroke();
                // Base
                ctx.beginPath();
                ctx.moveTo(100, 200);
                ctx.lineTo(156, 200);
                ctx.stroke();

            } else if (type === 'ORGANIC') {
                // Apple Icon
                ctx.beginPath();
                // Left curve
                ctx.moveTo(128, 70);
                ctx.bezierCurveTo(90, 50, 60, 90, 60, 140);
                ctx.bezierCurveTo(60, 190, 100, 220, 128, 200);
                // Right curve
                ctx.bezierCurveTo(156, 220, 196, 190, 196, 140);
                ctx.bezierCurveTo(196, 90, 166, 50, 128, 70);
                ctx.stroke();
                // Leaf
                ctx.beginPath();
                ctx.moveTo(128, 70);
                ctx.quadraticCurveTo(128, 40, 150, 30);
                ctx.quadraticCurveTo(160, 50, 128, 70);
                ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function createBin(x, y, z, color, typeId) {
            const width = 1.5;
            const height = 1.1; // REDUCED HEIGHT for easier access
            const depth = 1.5;
            const thickness = 0.1;

            const group = new THREE.Group();
            group.position.set(x, y + height/2, z);
            scene.add(group);

            // -- Visuals --
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
            
            // Icon Plate Material
            const iconTex = createIconTexture(typeId);
            const plateMat = new THREE.MeshStandardMaterial({ 
                map: iconTex,
                roughness: 0.3,
                metalness: 0.1,
                bumpMap: iconTex, // Simple bump effect from the drawing
                bumpScale: 0.05
            });

            // Bottom
            const bottomGeo = new THREE.BoxGeometry(width, thickness, depth);
            const bottomMesh = new THREE.Mesh(bottomGeo, material);
            bottomMesh.position.y = -height/2 + thickness/2;
            bottomMesh.castShadow = true;
            bottomMesh.receiveShadow = true;
            group.add(bottomMesh);

            // Walls
            const sideGeo = new THREE.BoxGeometry(thickness, height, depth);
            const backGeo = new THREE.BoxGeometry(width, height, thickness);

            // Left
            const left = new THREE.Mesh(sideGeo, material);
            left.position.set(-width/2 + thickness/2, 0, 0);
            left.castShadow = true;
            group.add(left);

            // Right
            const right = new THREE.Mesh(sideGeo, material);
            right.position.set(width/2 - thickness/2, 0, 0);
            right.castShadow = true;
            group.add(right);

            // Back
            const back = new THREE.Mesh(backGeo, material);
            back.position.set(0, 0, -depth/2 + thickness/2);
            back.castShadow = true;
            group.add(back);

            // Front Main Panel
            const frontGeo = new THREE.BoxGeometry(width, height, thickness);
            const front = new THREE.Mesh(frontGeo, material);
            front.position.set(0, 0, depth/2 - thickness/2);
            front.castShadow = true;
            group.add(front);

            // -- Relief Icon Plate --
            // A separate box mesh attached to the front to act as a 3D label
            const plateGeo = new THREE.BoxGeometry(0.8, 0.8, 0.05);
            const plate = new THREE.Mesh(plateGeo, plateMat);
            // Position it on the face of the front panel
            plate.position.set(0, 0, depth/2 + 0.02); 
            plate.castShadow = true; // Plate casts shadow on bin for relief effect
            group.add(plate);

            // -- Physics --
            const binBody = new CANNON.Body({ mass: 0, material: binMat });
            binBody.position.set(x, y + height/2, z);

            // Bottom Shape
            const bottomShape = new CANNON.Box(new CANNON.Vec3(width/2, thickness/2, depth/2));
            binBody.addShape(bottomShape, new CANNON.Vec3(0, -height/2 + thickness/2, 0));

            // Wall Shapes
            const sideShape = new CANNON.Box(new CANNON.Vec3(thickness/2, height/2, depth/2));
            const backFrontShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, thickness/2));

            binBody.addShape(sideShape, new CANNON.Vec3(-width/2 + thickness/2, 0, 0)); // Left
            binBody.addShape(sideShape, new CANNON.Vec3(width/2 - thickness/2, 0, 0)); // Right
            binBody.addShape(backFrontShape, new CANNON.Vec3(0, 0, -depth/2 + thickness/2)); // Back
            binBody.addShape(backFrontShape, new CANNON.Vec3(0, 0, depth/2 - thickness/2)); // Front

            world.addBody(binBody);

            // -- Sensor for scoring --
            const sensorShape = new CANNON.Box(new CANNON.Vec3(width/2 - thickness*2, 0.1, depth/2 - thickness*2));
            const sensorBody = new CANNON.Body({ isTrigger: true });
            sensorBody.addShape(sensorShape);
            sensorBody.position.set(x, y + 0.2, z);
            sensorBody.binType = typeId; 
            world.addBody(sensorBody);

            sensorBody.addEventListener('collide', (e) => {
                if (e.body === trashBody) {
                    // FIXED: Defer to next tick to avoid removing body during step
                    setTimeout(() => handleScore(typeId), 0);
                }
            });
        }

        // --- Trash Logic ---

        function getRandomTrashConfig() {
            const types = Object.keys(TRASH_TYPES);
            const typeKey = types[Math.floor(Math.random() * types.length)];
            const type = TRASH_TYPES[typeKey];
            
            let geometry, shape, scale = 1, color = 0xffffff;

            if (typeKey === 'PAPER') {
                geometry = new THREE.IcosahedronGeometry(0.15, 0); 
                shape = new CANNON.Sphere(0.15);
                color = 0xeeeeee;
            } else if (typeKey === 'PLASTIC') {
                geometry = new THREE.CylinderGeometry(0.08, 0.08, 0.35, 10);
                shape = new CANNON.Cylinder(0.08, 0.08, 0.35, 10);
                color = 0x33CCFF;
            } else if (typeKey === 'GLASS') {
                geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.25, 12);
                shape = new CANNON.Cylinder(0.1, 0.1, 0.25, 12);
                color = 0x00aa44;
            } else { // Organic
                geometry = new THREE.DodecahedronGeometry(0.12);
                shape = new CANNON.Sphere(0.12);
                color = 0x8D6E63;
            }

            return { type: typeKey, geometry, shape, color, label: type.label };
        }

        function spawnTrash() {
            if (trashBody) {
                world.removeBody(trashBody);
                scene.remove(trashMesh);
            }

            const config = getRandomTrashConfig();
            currentTrashType = config.type;

            document.getElementById('current-item-label').innerText = "CURRENT ITEM: " + config.label;
            document.getElementById('current-item-label').style.color = '#' + TRASH_TYPES[config.type].color.toString(16);

            const material = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.8 });
            trashMesh = new THREE.Mesh(config.geometry, material);
            trashMesh.castShadow = true;
            scene.add(trashMesh);

            trashBody = new CANNON.Body({ mass: 0.5, material: trashPhysMat });
            trashBody.addShape(config.shape);
            
            world.addBody(trashBody);
            
            trashBody.mass = 0;
            trashBody.type = CANNON.Body.KINEMATIC;
            trashBody.updateMassProperties();
            trashBody.velocity.set(0,0,0);
            trashBody.angularVelocity.set(0,0,0);
            trashBody.collisionFilterGroup = 0; 
            trashBody.collisionFilterMask = 0;

            isTrashThrown = false;
            canThrow = true;
            trajectoryLine.visible = true;
            
            // Reset timers
            stationaryTimer = 0;
            throwTimestamp = 0;
        }

        function getThrowVectors() {
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            const right = new THREE.Vector3();
            right.crossVectors(direction, camera.up).normalize();
            
            const startPos = camera.position.clone()
                .add(direction.clone().multiplyScalar(0.5)) 
                .add(right.clone().multiplyScalar(0.2)) 
                .add(camera.up.clone().multiplyScalar(-0.1)); 
            
            const velocityDir = direction.clone();
            velocityDir.y += 0.15; 
            velocityDir.normalize();

            return { startPos, velocityDir };
        }

        function throwTrash() {
            if (isTrashThrown || !canThrow) return;

            isTrashThrown = true;
            canThrow = false;
            trajectoryLine.visible = false;
            
            throwTimestamp = Date.now();
            stationaryTimer = 0;

            world.removeBody(trashBody);
            trashBody.type = CANNON.Body.DYNAMIC;
            trashBody.mass = 0.8; 
            trashBody.updateMassProperties();
            
            trashBody.collisionFilterGroup = 1;
            trashBody.collisionFilterMask = 1;
            
            const force = 12; 
            const { startPos, velocityDir } = getThrowVectors();
            
            trashBody.position.copy(startPos);
            world.addBody(trashBody);
            
            trashBody.velocity.set(
                velocityDir.x * force,
                velocityDir.y * force,
                velocityDir.z * force
            );

            trashBody.angularVelocity.set(Math.random()*10, Math.random()*10, Math.random()*10);
        }

        function updateTrajectory() {
            if (isTrashThrown || !canThrow || !controls.isLocked) {
                trajectoryLine.visible = false;
                return;
            }
            trajectoryLine.visible = true;

            const { startPos, velocityDir } = getThrowVectors();
            const force = 12; 
            const velocity = velocityDir.multiplyScalar(force);
            const gravity = new THREE.Vector3(0, -15, 0); 

            const points = [];
            const steps = 30; 
            const timeStep = 0.05; 

            for (let i = 0; i < steps; i++) {
                const t = i * timeStep;
                const pos = new THREE.Vector3().copy(startPos)
                    .add(velocity.clone().multiplyScalar(t))
                    .add(gravity.clone().multiplyScalar(0.5 * t * t));
                
                points.push(pos);
                if (pos.y < 0) break; 
            }
            
            trajectoryLine.geometry.setFromPoints(points);
        }

        function handleScore(binType) {
            if (!isTrashThrown) return; 

            const feedbackEl = document.getElementById('feedback');
            
            if (binType === 'VOID') {
                score -= 50; 
                feedbackEl.innerText = "MISS! -50";
                feedbackEl.style.color = "#FFC107"; 
            } else {
                const isCorrect = binType === currentTrashType;
                
                if (isCorrect) {
                    score += 100;
                    feedbackEl.innerText = "CORRECT! +100";
                    feedbackEl.style.color = "#4CAF50";
                } else {
                    score -= 50;
                    feedbackEl.innerText = "WRONG! -50";
                    feedbackEl.style.color = "#F44336";
                }
            }

            document.getElementById('score').innerText = score;
            
            feedbackEl.style.opacity = 1;
            setTimeout(() => { feedbackEl.style.opacity = 0; }, 1000);

            // Remove trash and respawn after delay
            isTrashThrown = false; 
            if (trashBody) world.removeBody(trashBody);
            if (trashMesh) scene.remove(trashMesh);
            trashBody = null;

            // Faster respawn (was 1000)
            setTimeout(spawnTrash, 300); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); 

                const speed = 15.0; 

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                const pos = controls.getObject().position;
                pos.y = 1.8; 
                
                if (pos.x < -15) pos.x = -15;
                if (pos.x > 15) pos.x = 15;
                if (pos.z < -5) pos.z = -5; 
                if (pos.z > 20) pos.z = 20; 
            }

            prevTime = time;
            
            updateTrajectory();
            
            // New: update particles
            updateWeatherParticles(delta);

            // FIXED: Use standard world.step(1/60) to prevent wakeUpAfterNarrowphase error
            world.step(1/60); 

            if (trashBody && trashMesh) {
                if (!isTrashThrown) {
                    const { startPos } = getThrowVectors();
                    trashBody.position.copy(startPos);
                    trashBody.quaternion.copy(camera.quaternion);
                } else {
                    // Logic to detect stopped/stuck trash for auto-respawn
                    if (trashBody.velocity.lengthSquared() < 0.05) {
                        stationaryTimer += delta;
                        if (stationaryTimer > 0.5) { // Faster timeout (was 1.0)
                             handleScore('VOID');
                             stationaryTimer = 0;
                             // EXIT IMMEDIATELY to prevent null access later in this frame
                             return; 
                        }
                    } else {
                        stationaryTimer = 0;
                    }
                    
                    // Fallback timeout: if 2 seconds passed since throw, force respawn (was 5000)
                    if (Date.now() - throwTimestamp > 2000) {
                        handleScore('VOID');
                        return; // EXIT IMMEDIATELY
                    }
                }
                
                // IMPORTANT: Re-check trashBody exists before accessing .position
                // because handleScore() might have run (sync or nearly sync) and nulled it.
                if (trashBody) {
                    trashMesh.position.copy(trashBody.position);
                    trashMesh.quaternion.copy(trashBody.quaternion);

                    if (isTrashThrown && trashBody.position.y < -5) {
                        handleScore('VOID'); 
                        return;
                    }
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>