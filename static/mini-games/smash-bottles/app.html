<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Railroad Bottle Smash (Three.js + Cannon.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        
        #info {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 100;
            user-select: none;
            border-bottom: 1px solid #444;
        }

        .logo {
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
        }

        .center-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #stats {
            font-size: 1.1rem;
            color: #fff;
            font-weight: bold;
        }

        .stat-val {
            color: #4CAF50;
            margin: 0 2px;
        }
        
        /* –¶–≤–µ—Ç –¥–ª—è –∫–∞–º–Ω–µ–π, —á—Ç–æ–±—ã –≤—ã–¥–µ–ª—è–ª—Å—è */
        #stonesVal {
            color: #FFC107; 
        }
        
        .divider {
            color: #555;
            margin: 0 8px;
        }

        #season-info {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 2px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #resetBtn {
            padding: 6px 16px;
            font-size: 0.9rem;
            cursor: pointer;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            transition: background 0.2s;
            text-transform: uppercase;
        }
        #resetBtn:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <div id="info">
        <div class="logo">üî® Smash Glass</div>
        
        <div class="center-panel">
            <div id="stats">
                Smashed: <span id="scoreVal" class="stat-val">0</span>
                <span class="divider">|</span>
                Remaining: <span id="remainingVal" class="stat-val">0</span>
                <span class="divider">|</span>
                Stones: <span id="stonesVal" class="stat-val">20</span>
            </div>
            <div id="season-info">SEASON: SUMMER</div>
        </div>

        <button id="resetBtn">Generate World</button>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let world;
        
        let stack = []; 
        let shards = [];
        let stones = [];
        let environmentObjects = []; 
        
        let score = 0;
        let stonesLeft = 20; // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
        const mouseIntersection = new THREE.Vector3();
        let aimMarker;

        let groundMaterial, glassMaterial, stoneMaterial, railMaterial;

        const SLEEPER_HEIGHT = 0.1;
        const RAIL_HEIGHT = 0.15;
        const RAIL_TOP_Y = SLEEPER_HEIGHT + RAIL_HEIGHT; 
        const WORLD_LENGTH = 400;

        const SEASONS = {
            SUMMER: { 
                name: "Summer",
                sky: 0x87CEEB, 
                fogNear: 30, fogFar: 90,
                ground: 0x3a5f0b, 
                leaves: [0x2e7d32, 0x43a047], 
                wood: 0x5d4037,
                gravel: 0x555555,
                lightInt: 1.2
            },
            AUTUMN: { 
                name: "Autumn",
                sky: 0xFFDAB9, 
                fogNear: 20, fogFar: 80,
                ground: 0x8B4513, 
                leaves: [0xFF4500, 0xFFA500, 0xD2691E, 0x8B0000], 
                wood: 0x4d3328,
                gravel: 0x4a4a4a,
                lightInt: 1.0
            },
            WINTER: { 
                name: "Winter",
                sky: 0xD3D3D3, 
                fogNear: 15, fogFar: 70,
                ground: 0xFFFFFF, 
                leaves: [0xFFFFFF, 0xEEEEEE], 
                wood: 0x2F4F4F,
                gravel: 0xDDDDDD, 
                lightInt: 0.9
            },
            SPRING: { 
                name: "Spring",
                sky: 0xB0E0E6, 
                fogNear: 30, fogFar: 100,
                ground: 0x66CDAA, 
                leaves: [0xFF69B4, 0xFFB6C1, 0x32CD32], 
                wood: 0x6d4c41,
                gravel: 0x666666,
                lightInt: 1.1
            }
        };

        let currentSeason = SEASONS.SUMMER;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 5, 12);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                powerPreference: "high-performance",
                precision: "highp", 
                stencil: false 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            try {
                const gl = renderer.getContext();
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    const rendererVal = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    console.log(`[GPU Debug] Vendor: ${vendor}`);
                    console.log(`[GPU Debug] Renderer: ${rendererVal}`);
                }
            } catch(e) {
                console.warn("[GPU Debug] Failed to get GPU info");
            }

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            controls.minDistance = 5;
            controls.maxDistance = 40;
            controls.target.set(0, 0, 0);
            controls.mouseButtons = {
                LEFT: null, 
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            };

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.name = "sun";
            dirLight.position.set(30, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            const markerGeo = new THREE.RingGeometry(0.1, 0.15, 16);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
            aimMarker = new THREE.Mesh(markerGeo, markerMat);
            aimMarker.rotation.x = -Math.PI / 2;
            aimMarker.visible = false;
            scene.add(aimMarker);

            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 20;

            groundMaterial = new CANNON.Material('ground');
            glassMaterial = new CANNON.Material('glass');
            stoneMaterial = new CANNON.Material('stone');
            railMaterial = new CANNON.Material('rail');

            world.addContactMaterial(new CANNON.ContactMaterial(glassMaterial, groundMaterial, { friction: 0.5, restitution: 0.3 }));
            world.addContactMaterial(new CANNON.ContactMaterial(glassMaterial, railMaterial, { friction: 0.6, restitution: 0.1 })); 
            world.addContactMaterial(new CANNON.ContactMaterial(stoneMaterial, glassMaterial, { friction: 0.3, restitution: 0.4 }));
            world.addContactMaterial(new CANNON.ContactMaterial(stoneMaterial, groundMaterial, { friction: 0.7, restitution: 0.2 }));

            regenerateWorld();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('contextmenu', e => e.preventDefault());
            
            document.getElementById('resetBtn').addEventListener('click', (e) => {
                if(e) e.stopPropagation();
                regenerateWorld();
            });
        }

        function updateUI() {
            const remaining = stack.filter(obj => obj.isBottle).length;
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('remainingVal').innerText = remaining;
            document.getElementById('stonesVal').innerText = stonesLeft; // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–º–Ω–∏
            document.getElementById('season-info').innerText = "SEASON: " + currentSeason.name;
        }

        function clearWorld() {
            for (let i = stack.length - 1; i >= 0; i--) {
                const obj = stack[i];
                world.removeBody(obj.body);
                scene.remove(obj.mesh);
            }
            stack = [];
            shards = [];
            stones = [];

            for (let i = 0; i < environmentObjects.length; i++) {
                const obj = environmentObjects[i];
                if (obj.body) world.removeBody(obj.body);
                if (obj.mesh) {
                    scene.remove(obj.mesh);
                    if(obj.mesh.geometry) obj.mesh.geometry.dispose();
                    if(obj.mesh.material) {
                        if (Array.isArray(obj.mesh.material)) {
                            obj.mesh.material.forEach(m => m.dispose());
                        } else {
                            obj.mesh.material.dispose();
                        }
                    }
                }
            }
            environmentObjects = [];
        }

        function pickRandomSeason() {
            const keys = Object.keys(SEASONS);
            const randomKey = keys[Math.floor(Math.random() * keys.length)];
            currentSeason = SEASONS[randomKey];
            
            scene.background = new THREE.Color(currentSeason.sky);
            scene.fog = new THREE.Fog(currentSeason.sky, currentSeason.fogNear, currentSeason.fogFar);
            
            const sun = scene.getObjectByName("sun");
            if(sun) sun.intensity = currentSeason.lightInt;
        }

        function regenerateWorld() {
            clearWorld();
            pickRandomSeason();
            createEnvironment();
            spawnBottles();
            stonesLeft = 20; // –°–±—Ä–æ—Å –∫–∞–º–Ω–µ–π
            updateUI();
        }

        function createEnvironment() {
            const hasRiver = Math.random() > 0.5;
            const hasPonds = !hasRiver && Math.random() > 0.3; 
            
            let riverZ = 0;
            let riverWidth = 0;
            if (hasRiver) {
                riverWidth = 8 + Math.random() * 8;
                riverZ = (Math.random() - 0.5) * 20;
            }

            if (!hasRiver) {
                createLandscapeSegment(-WORLD_LENGTH/2, WORLD_LENGTH/2);
            } else {
                const riverStart = riverZ - riverWidth/2;
                const riverEnd = riverZ + riverWidth/2;
                
                createLandscapeSegment(-WORLD_LENGTH/2, riverStart);
                createRiver(riverZ, riverWidth);
                createLandscapeSegment(riverEnd, WORLD_LENGTH/2);
            }

            generateFloraAndClouds(hasRiver, riverZ, riverWidth);
            generateTrack(hasRiver, riverZ, riverWidth);
        }

        function createLandscapeSegment(zStart, zEnd) {
            const length = zEnd - zStart;
            const zCenter = (zStart + zEnd) / 2;
            const bankWidth = 4;
            const bankHeight = 2;
            const groundLevel = -1.5; 
            const slopeWidth = 60;

            const gravelMat = new THREE.MeshStandardMaterial({ color: currentSeason.gravel, roughness: 1.0 });
            const grassMat = new THREE.MeshStandardMaterial({ color: currentSeason.ground, roughness: 1.0 });
            const slopeMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 1.0 });

            // 1. Embankment
            const bankGeo = new THREE.BoxGeometry(bankWidth, bankHeight, length);
            const bankMesh = new THREE.Mesh(bankGeo, gravelMat);
            bankMesh.position.set(0, -bankHeight/2, zCenter);
            bankMesh.receiveShadow = true;
            scene.add(bankMesh);
            environmentObjects.push({ mesh: bankMesh });

            const bankShape = new CANNON.Box(new CANNON.Vec3(bankWidth/2, bankHeight/2, length/2));
            const bankBody = new CANNON.Body({ mass: 0, material: groundMaterial });
            bankBody.addShape(bankShape);
            bankBody.position.set(0, -bankHeight/2, zCenter);
            world.addBody(bankBody);
            environmentObjects.push({ body: bankBody });

            // 2. Lower Ground
            const groundThickness = 5; 
            const groundY = groundLevel - groundThickness/2;

            const leftGeo = new THREE.BoxGeometry(slopeWidth, groundThickness, length);
            const leftMesh = new THREE.Mesh(leftGeo, grassMat);
            leftMesh.position.set(-bankWidth/2 - slopeWidth/2, groundY, zCenter);
            leftMesh.receiveShadow = true;
            scene.add(leftMesh);
            environmentObjects.push({ mesh: leftMesh });

            const leftShape = new CANNON.Box(new CANNON.Vec3(slopeWidth/2, groundThickness/2, length/2));
            const leftBody = new CANNON.Body({ mass: 0, material: groundMaterial });
            leftBody.addShape(leftShape);
            leftBody.position.copy(leftMesh.position);
            world.addBody(leftBody);
            environmentObjects.push({ body: leftBody });

            const rightMesh = leftMesh.clone();
            rightMesh.position.set(bankWidth/2 + slopeWidth/2, groundY, zCenter);
            scene.add(rightMesh);
            environmentObjects.push({ mesh: rightMesh });

            const rightBody = new CANNON.Body({ mass: 0, material: groundMaterial });
            rightBody.addShape(leftShape);
            rightBody.position.copy(rightMesh.position);
            world.addBody(rightBody);
            environmentObjects.push({ body: rightBody });

            // 3. Slopes
            const slopeGeo = new THREE.PlaneGeometry(2.5, length);
            
            const leftSlope = new THREE.Mesh(slopeGeo, slopeMat);
            leftSlope.position.set(-bankWidth/2 - 0.8, -0.75, zCenter);
            leftSlope.rotation.set(-Math.PI/2, 0, -0.6);
            leftSlope.receiveShadow = true;
            scene.add(leftSlope);
            environmentObjects.push({ mesh: leftSlope });

            const rightSlope = new THREE.Mesh(slopeGeo, slopeMat);
            rightSlope.position.set(bankWidth/2 + 0.8, -0.75, zCenter);
            rightSlope.rotation.set(-Math.PI/2, 0, 0.6);
            rightSlope.receiveShadow = true;
            scene.add(rightSlope);
            environmentObjects.push({ mesh: rightSlope });
        }

        function createRiver(z, width) {
            const waterLevel = -2.0; 
            const waterGeo = new THREE.PlaneGeometry(150, width);
            const waterMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x006994, 
                transparent: true, 
                opacity: 0.8, 
                roughness: 0.1, 
                metalness: 0.2 
            });
            if (currentSeason.name === "Winter") {
                waterMat.color.setHex(0xE0FFFF);
                waterMat.opacity = 0.95;
                waterMat.roughness = 0.4;
            }

            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI/2;
            water.position.set(0, waterLevel, z);
            scene.add(water);
            environmentObjects.push({ mesh: water });

            const bedGeo = new THREE.PlaneGeometry(150, width);
            const bedMat = new THREE.MeshStandardMaterial({ color: 0x2b2b2b });
            const bed = new THREE.Mesh(bedGeo, bedMat);
            bed.rotation.x = -Math.PI/2;
            bed.position.set(0, -5, z);
            scene.add(bed);
            environmentObjects.push({ mesh: bed });

            const pillarGeo = new THREE.CylinderGeometry(0.4, 0.4, 4);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            
            const bridgeStart = z - width/2;
            const bridgeEnd = z + width/2;
            
            const pillarPositions = [
                {x: -1.0, z: bridgeStart + 0.5}, {x: 1.0, z: bridgeStart + 0.5},
                {x: -1.0, z: bridgeEnd - 0.5}, {x: 1.0, z: bridgeEnd - 0.5}
            ];
            
            pillarPositions.forEach(p => {
                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                pillar.position.set(p.x, -2, p.z);
                pillar.castShadow = true;
                scene.add(pillar);
                environmentObjects.push({ mesh: pillar });
            });

            const girderGeo = new THREE.BoxGeometry(0.5, 0.3, width); 
            const girderMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            [-0.4, 0.4].forEach(x => {
                const girder = new THREE.Mesh(girderGeo, girderMat);
                girder.position.set(x, 0, z); 
                girder.position.y = -0.15; 
                scene.add(girder);
                environmentObjects.push({ mesh: girder });
            });
        }

        function generateFloraAndClouds(hasRiver, riverZ, riverWidth) {
            const treeCount = 150;
            const groundLevel = -1.5;
            for (let i = 0; i < treeCount; i++) {
                const side = Math.random() > 0.5 ? 1 : -1;
                const dist = 5 + Math.random() * 25; 
                const x = side * dist;
                const z = (Math.random() - 0.5) * WORLD_LENGTH * 0.9; 
                
                if (hasRiver && z > riverZ - riverWidth/2 - 2 && z < riverZ + riverWidth/2 + 2) continue;

                const scale = 0.8 + Math.random() * 0.8;
                if (Math.abs(z) < 120) {
                    createTree(x, groundLevel, z, scale);
                }
            }

            const cloudCount = currentSeason.name === "Winter" ? 30 : 20; 
            for (let i = 0; i < cloudCount; i++) {
                createCloud();
            }
        }

        function generateTrack(hasRiver, riverZ, riverWidth) {
            const railLength = WORLD_LENGTH;
            const railGauge = 0.8; 
            const railWidth = 0.1;
            const sleeperWidth = 1.6;
            const sleeperDepth = 0.3;
            const sleeperSpacing = 0.8;

            const railMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, metalness: 0.6 });
            const sleeperMat = new THREE.MeshStandardMaterial({ color: 0x3B2F2F, roughness: 0.9 });
            
            const sleeperCount = Math.floor(railLength / sleeperSpacing);
            const sleeperGeo = new THREE.BoxGeometry(sleeperWidth, SLEEPER_HEIGHT, sleeperDepth);
            const sleeperInstancedMesh = new THREE.InstancedMesh(sleeperGeo, sleeperMat, sleeperCount);
            
            sleeperInstancedMesh.receiveShadow = true;
            sleeperInstancedMesh.castShadow = true;
            
            const dummy = new THREE.Object3D();
            let sleeperIdx = 0;
            
            for (let z = -railLength / 2; z <= railLength / 2; z += sleeperSpacing) {
                if (sleeperIdx >= sleeperCount) break;
                
                dummy.position.set(0, SLEEPER_HEIGHT / 2, z);
                dummy.updateMatrix();
                sleeperInstancedMesh.setMatrixAt(sleeperIdx, dummy.matrix);
                
                const isOverBridge = hasRiver && (z > riverZ - riverWidth/2 && z < riverZ + riverWidth/2);
                const isNearCenter = Math.abs(z) < 40;

                if (isNearCenter || isOverBridge) {
                    const sleeperShape = new CANNON.Box(new CANNON.Vec3(sleeperWidth / 2, SLEEPER_HEIGHT / 2, sleeperDepth / 2));
                    const sleeperBody = new CANNON.Body({ mass: 0, material: railMaterial });
                    sleeperBody.addShape(sleeperShape);
                    sleeperBody.position.set(0, SLEEPER_HEIGHT / 2, z);
                    world.addBody(sleeperBody);
                    environmentObjects.push({ body: sleeperBody });
                }
                
                sleeperIdx++;
            }
            scene.add(sleeperInstancedMesh);
            environmentObjects.push({ mesh: sleeperInstancedMesh });

            [-1, 1].forEach(side => {
                const xPos = (railGauge / 2) * side;
                const yPos = SLEEPER_HEIGHT + RAIL_HEIGHT / 2;

                // Visual Rail
                const railGeo = new THREE.BoxGeometry(railWidth, RAIL_HEIGHT, railLength);
                const railMesh = new THREE.Mesh(railGeo, railMat);
                railMesh.position.set(xPos, yPos, 0);
                railMesh.castShadow = true;
                railMesh.receiveShadow = true;
                scene.add(railMesh);
                environmentObjects.push({ mesh: railMesh });

                // Physics Rail
                const wideRailWidth = 0.35; // Wider for stability
                const railShape = new CANNON.Box(new CANNON.Vec3(wideRailWidth / 2, RAIL_HEIGHT / 2, railLength / 2));
                const railBody = new CANNON.Body({ mass: 0, material: railMaterial });
                railBody.addShape(railShape);
                // Shift physics up slightly (0.02) so bottle sits ON visual rail, not IN it
                railBody.position.set(xPos, yPos + 0.02, 0);
                world.addBody(railBody);
                environmentObjects.push({ body: railBody });
            });
        }

        function createTree(x, y, z, scale) {
            const treeGroup = new THREE.Group();
            
            const trunkGeo = new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, 1.5 * scale, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: currentSeason.wood });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = (1.5 * scale) / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            const leafColor = currentSeason.leaves[Math.floor(Math.random() * currentSeason.leaves.length)];
            const leavesMat = new THREE.MeshStandardMaterial({ color: leafColor, flatShading: true });
            
            const cone1 = new THREE.Mesh(new THREE.ConeGeometry(1.2 * scale, 2 * scale, 7), leavesMat);
            cone1.position.y = 1.5 * scale;
            cone1.castShadow = true;
            treeGroup.add(cone1);

            const cone2 = new THREE.Mesh(new THREE.ConeGeometry(0.9 * scale, 1.5 * scale, 7), leavesMat);
            cone2.position.y = 2.5 * scale;
            cone2.castShadow = true;
            treeGroup.add(cone2);

            treeGroup.position.set(x, y, z);
            treeGroup.rotation.z = (Math.random() - 0.5) * 0.1;
            treeGroup.rotation.x = (Math.random() - 0.5) * 0.1;
            
            scene.add(treeGroup);
            environmentObjects.push({ mesh: treeGroup });
        }

        function createCloud() {
            const cloudGroup = new THREE.Group();
            const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            if (currentSeason.name === "Winter") cloudMat.color.setHex(0xdddddd);
            if (currentSeason.name === "Autumn") cloudMat.opacity = 0.6; 

            const blocks = 3 + Math.floor(Math.random() * 3);
            for(let i=0; i<blocks; i++) {
                const s = 1 + Math.random() * 1.5;
                const geo = new THREE.BoxGeometry(s, s, s); 
                const mesh = new THREE.Mesh(geo, cloudMat);
                mesh.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 1.5
                );
                cloudGroup.add(mesh);
            }

            cloudGroup.position.set(
                (Math.random() - 0.5) * 100, 
                15 + Math.random() * 10,
                (Math.random() - 0.5) * 100 - 20
            );
            
            scene.add(cloudGroup);
            environmentObjects.push({ mesh: cloudGroup });
        }

        function spawnBottles() {
            for(let i = -4; i <= 4; i++) {
                if (Math.random() > 0.3) { 
                    const z = i * 1.2 + (Math.random() - 0.5) * 0.4;
                    const xCenter = (Math.random() > 0.5 ? 0.4 : -0.4);
                    const x = xCenter + (Math.random() - 0.5) * 0.04;
                    createRandomBottle(x, z);
                }
            }
        }

        function createRandomBottle(x, z) {
            const type = Math.floor(Math.random() * 3);
            let bottleData;

            switch(type) {
                case 0: // Classic
                    bottleData = { bodyR: 0.12, bodyH: 0.5, neckR: 0.06, neckH: 0.3, color: 0x2E8B57 };
                    break;
                case 1: // Tall
                    bottleData = { bodyR: 0.09, bodyH: 0.7, neckR: 0.05, neckH: 0.4, color: 0xA0522D }; 
                    break;
                case 2: // Round
                    bottleData = { bodyR: 0.15, bodyH: 0.4, neckR: 0.07, neckH: 0.25, color: 0x4682B4 }; 
                    break;
            }
            
            const spawnY = RAIL_TOP_Y + bottleData.bodyH / 2 + 0.05;
            createBottle(x, spawnY, z, bottleData);
        }

        function createBottle(x, y, z, data) {
            const { bodyR, bodyH, neckR, neckH, color } = data;
            
            const bottleGeo = new THREE.CylinderGeometry(bodyR, bodyR, bodyH, 16);
            const neckGeo = new THREE.CylinderGeometry(neckR, neckR, neckH, 16);
            neckGeo.translate(0, bodyH / 2 + neckH / 2, 0);
            
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: color,
                metalness: 0,
                roughness: 0.1,
                transmission: 0.9,
                thickness: 0.05,
                transparent: true,
                side: THREE.DoubleSide
            });

            const bottleGroup = new THREE.Group();
            const bodyMesh = new THREE.Mesh(bottleGeo, glassMat);
            const neckMesh = new THREE.Mesh(neckGeo, glassMat);
            
            bodyMesh.castShadow = true;
            neckMesh.castShadow = true;
            
            bottleGroup.add(bodyMesh);
            bottleGroup.add(neckMesh);
            scene.add(bottleGroup);

            // Shape alignment fix:
            // cannon-es cylinder is Y-aligned by default (vertical).
            // Three.js visual mesh is Y-aligned (vertical).
            // No rotation is needed for shapeBody to match visual.
            const shapeBody = new CANNON.Cylinder(bodyR, bodyR, bodyH, 16);
            const shapeNeck = new CANNON.Cylinder(neckR, neckR, neckH, 16);
            
            // NOTE: Removed quaternion rotation here because it was flipping cylinder 90 deg!
            
            const body = new CANNON.Body({ mass: 0.5, material: glassMaterial });
            
            // Add shapes centered (offset is 0,0,0 relative to body center)
            // But we need to position them relative to body center if body center is bottle center.
            // body pos is (x, y, z).
            // Cylinder 1 is main body.
            // Cylinder 2 is neck, shifted up.
            
            body.addShape(shapeBody, new CANNON.Vec3(0, 0, 0));
            body.addShape(shapeNeck, new CANNON.Vec3(0, bodyH / 2 + neckH / 2, 0));
            
            body.position.set(x, y, z);
            body.angularDamping = 0.5;
            body.linearDamping = 0.5;
            
            world.addBody(body);

            const obj = { 
                mesh: bottleGroup, 
                body: body, 
                isBottle: true,
                spawnTime: Date.now() 
            };
            stack.push(obj);

            body.addEventListener("collide", (e) => {
                if (Date.now() - obj.spawnTime < 500) {
                     if (['rail', 'sleeper', 'ground'].includes(e.body.name)) return;
                }

                if (['rail', 'sleeper', 'ground'].includes(e.body.name)) {
                    if (Math.abs(e.contact.getImpactVelocityAlongNormal()) < 4) return;
                }
                
                if (e.body.name === 'stone') {
                     shatterBottle(obj, e.contact.ni, e.body.velocity);
                } 
                else if (Math.abs(e.contact.getImpactVelocityAlongNormal()) > 3) {
                    shatterBottle(obj, e.contact.ni);
                }
            });
        }

        function shatterBottle(obj, normal, impactVelocity) {
            const index = stack.indexOf(obj);
            if (index > -1) {
                score++;
                stack.splice(index, 1);
                world.removeBody(obj.body);
                scene.remove(obj.mesh);
                createShards(obj.body.position, normal, impactVelocity);
                updateUI();
            }
        }

        function createShards(pos, normal, impactVelocity) {
            const shardCount = 15;
            const spread = 0.3;

            for (let i = 0; i < shardCount; i++) {
                const s = 0.03 + Math.random() * 0.08;
                
                const geo = new THREE.TetrahedronGeometry(s);
                const mat = new THREE.MeshPhysicalMaterial({
                    color: 0xAAAAAA, 
                    transmission: 0.9,
                    roughness: 0.1,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true;
                scene.add(mesh);

                const shape = new CANNON.Box(new CANNON.Vec3(s/2, s/2, s/2));
                const body = new CANNON.Body({ mass: 0.05, material: glassMaterial });
                body.addShape(shape);
                
                body.position.set(
                    pos.x + (Math.random() - 0.5) * spread,
                    pos.y + (Math.random() - 0.5) * spread,
                    pos.z + (Math.random() - 0.5) * spread
                );
                
                body.quaternion.set(Math.random(), Math.random(), Math.random(), Math.random());
                
                const force = 4;
                const velocity = new CANNON.Vec3(
                    (Math.random() - 0.5) * force,
                    Math.random() * force * 0.8 + 1, 
                    (Math.random() - 0.5) * force
                );

                if (impactVelocity) {
                    velocity.vadd(impactVelocity.scale(0.3), velocity);
                }
                
                body.velocity.copy(velocity);
                
                world.addBody(body);

                const shardObj = { mesh: mesh, body: body, createdAt: Date.now() };
                shards.push(shardObj);
                stack.push(shardObj);
            }
        }

        function throwStone() {
            if (stonesLeft <= 0) return; // Prevent throwing if out of stones
            stonesLeft--;
            updateUI();

            const startPos = camera.position.clone();
            startPos.y -= 0.5;
            const rightDir = new THREE.Vector3();
            camera.getWorldDirection(rightDir);
            rightDir.cross(camera.up).normalize();
            startPos.add(rightDir.multiplyScalar(0.5));

            const direction = new THREE.Vector3().subVectors(mouseIntersection, startPos);
            const distance = direction.length();
            direction.normalize();

            const radius = 0.08 + Math.random() * 0.04;
            const stoneGeo = new THREE.DodecahedronGeometry(radius, 0); 
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 1.0 });
            const stoneMesh = new THREE.Mesh(stoneGeo, stoneMat);
            stoneMesh.castShadow = true;
            scene.add(stoneMesh);

            const stoneShape = new CANNON.Sphere(radius); 
            const stoneBody = new CANNON.Body({ mass: 0.8, material: stoneMaterial });
            stoneBody.name = 'stone';
            stoneBody.addShape(stoneShape);
            stoneBody.position.copy(startPos);
            
            const speed = 15 + distance * 0.5; 
            const velocity = direction.multiplyScalar(speed);
            velocity.y += distance * 0.8; 

            stoneBody.velocity.copy(velocity);
            
            stoneBody.angularVelocity.set(
                Math.random() * 10,
                Math.random() * 10,
                Math.random() * 10
            );

            world.addBody(stoneBody);

            const stoneObj = { mesh: stoneMesh, body: stoneBody, isStone: true, createdAt: Date.now() };
            stones.push(stoneObj);
            stack.push(stoneObj);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            plane.constant = 0; 
            
            raycaster.ray.intersectPlane(plane, mouseIntersection);

            if (aimMarker) {
                aimMarker.position.copy(mouseIntersection);
                aimMarker.position.y = 0.05; 
                aimMarker.visible = true;
            }
        }

        function onMouseDown(event) {
            if (event.button === 0 && event.target.tagName !== 'BUTTON') { 
                throwStone();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const dt = 1 / 60;
            world.step(dt);

            for (let i = stack.length - 1; i >= 0; i--) {
                const obj = stack[i];
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);

                if (obj.body.position.y < -10) {
                    const idx = stack.indexOf(obj);
                    if (idx > -1) {
                         stack.splice(idx, 1);
                         world.removeBody(obj.body);
                         scene.remove(obj.mesh);
                         if (obj.isBottle) updateUI();
                    }
                }
            }

            if (stones.length > 15) {
                const oldStone = stones.shift();
                const idx = stack.indexOf(oldStone);
                if (idx > -1) {
                    stack.splice(idx, 1);
                    world.removeBody(oldStone.body);
                    scene.remove(oldStone.mesh);
                }
            }
            
            if (shards.length > 100) {
                const oldShard = shards.shift();
                const idx = stack.indexOf(oldShard);
                if (idx > -1) {
                    stack.splice(idx, 1);
                    world.removeBody(oldShard.body);
                    scene.remove(oldShard.mesh);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>