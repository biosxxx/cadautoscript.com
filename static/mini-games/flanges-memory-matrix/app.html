<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pressure Vessel: Safety Release</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1e293b; /* Slate 800 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Эффект металла на фоне контейнера */
            background: radial-gradient(circle at center, #334155 0%, #0f172a 100%);
            box-shadow: inset 0 0 100px #000;
        }
    </style>
    <script src="../../vendor/phaser.3.60.0.min.js"></script>
</head>
<body>

<div id="game-container"></div>

<script>
/**
 * ЦВЕТОВАЯ ПАЛИТРА: High Contrast Safety Colors
 */
const COLORS = {
    bgStart: 0x334155,
    bgEnd: 0x0f172a,
    
    // Фланец (открытый)
    flangeRim: 0x64748b,   // Серый металл
    flangeHole: 0x020617,  // Почти черный (дыра)
    
    // Заглушка (Blind Flange)
    blindFace: 0xcbd5e1,   // Светлый металл
    blindBolt: 0x475569,   // Темные болты
    
    // Индикация - High Contrast
    highlight: 0xFFD700,   // Ярко-золотой (Safety Yellow)
    error: 0xFF0000,       // Ярко-красный
    success: 0x00FF00,     // Ярко-зеленый (Lime)
    
    text: '#FFFFFF',       // Чистый белый
    textHighlight: '#FFFFFF'
};

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    preload() {
        // Процедурная графика
    }

    create() {
        this.level = 1;
        this.gridSize = 3; 
        this.tilesToMemorize = 3;
        this.lives = 3;
        
        this.grid = []; 
        this.sequence = []; 
        this.playerSequence = []; 
        this.isInputActive = false;
        
        this.baseTileSize = 100;
        this.baseTileGap = 15; 

        // Фон - клепаная сталь
        this.createVesselBackground();

        this.createUI();
        this.startLevel();
    }

    createVesselBackground() {
        const width = this.scale.width;
        const height = this.scale.height;
        const g = this.add.graphics();

        // Текстура сварных швов
        g.lineStyle(2, 0x000000, 0.3);
        
        // Вертикальные швы
        for(let x = width * 0.2; x < width; x += width * 0.3) {
            g.moveTo(x, 0);
            g.lineTo(x, height);
        }
        
        // Заклепки
        g.fillStyle(0x1e293b, 0.5);
        for(let x = width * 0.2; x < width; x += width * 0.3) {
            for(let y = 20; y < height; y += 60) {
                g.fillCircle(x - 10, y, 4);
                g.fillCircle(x + 10, y, 4);
            }
        }
    }

    createUI() {
        const width = this.scale.width;
        const safeTop = 60;

        // ЗАГОЛОВОК: Крупнее, белый, с черной обводкой
        this.titleText = this.add.text(width / 2, safeTop, 'SAFETY RELEASE', {
            fontFamily: 'Share Tech Mono',
            fontSize: '32px', 
            color: '#FFFFFF',
            letterSpacing: 2,
            stroke: '#000000',
            strokeThickness: 6,
            shadow: { offsetX: 3, offsetY: 3, color: '#000000', blur: 0, fill: true }
        }).setOrigin(0.5);
        
        // ПОДЗАГОЛОВОК: Яркий желтый с обводкой
        this.subTitleText = this.add.text(width / 2, safeTop + 35, 'OPEN REQUIRED VALVES', {
            fontFamily: 'Share Tech Mono',
            fontSize: '18px',
            color: '#FFD700', // Gold
            stroke: '#000000',
            strokeThickness: 4
        }).setOrigin(0.5);

        // УРОВЕНЬ: Белый с обводкой
        this.levelText = this.add.text(20, safeTop + 80, `PRESSURE-LVL: 00${this.level}`, {
            fontFamily: 'Share Tech Mono',
            fontSize: '20px',
            color: '#FFFFFF',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0, 0.5);

        this.livesGroup = this.add.group();
        this.updateLivesUI();

        // Оверлей
        this.overlay = this.add.container(0, 0);
        this.overlayBg = this.add.rectangle(width/2, this.scale.height/2, width, this.scale.height, 0x000000, 0.9); // Более темный фон для контраста
        
        this.overlayText = this.add.text(width/2, this.scale.height/2 - 30, "SYSTEM LOCKED", {
            fontFamily: 'Share Tech Mono',
            fontSize: '36px',
            color: '#FFD700',
            stroke: '#000000',
            strokeThickness: 6,
            align: 'center'
        }).setOrigin(0.5);
        
        this.overlaySubText = this.add.text(width/2, this.scale.height/2 + 40, "Memorize active valves to OPEN", {
            fontFamily: 'Share Tech Mono',
            fontSize: '20px',
            color: '#FFFFFF',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5);

        this.overlay.add([this.overlayBg, this.overlayText, this.overlaySubText]);
        this.overlay.setDepth(100);

        this.overlayBg.setInteractive();
        this.overlayBg.on('pointerdown', () => {
            if (this.lives <= 0) {
                this.restartGame();
            } else {
                this.hideOverlay();
                this.nextTurn();
            }
        });
        
        this.isGameRunning = false;
    }

    updateLivesUI() {
        this.livesGroup.clear(true, true);
        const startX = this.scale.width - 35;
        const startY = 85;
        
        for (let i = 0; i < 3; i++) {
            const isActive = i < this.lives;
            const x = startX - (i * 45); // Чуть шире расстановка
            
            const c = this.add.container(x, startY);
            const g = this.add.graphics();
            
            // Корпус манометра - более контрастный
            g.lineStyle(3, 0xFFFFFF, 1);
            g.fillStyle(0x000000, 1);
            g.fillCircle(0, 0, 16); // Чуть крупнее
            g.strokeCircle(0, 0, 16);
            
            // Шкала
            g.lineStyle(3, isActive ? COLORS.success : COLORS.error, 1);
            g.beginPath();
            g.arc(0, 0, 10, Phaser.Math.DegToRad(135), Phaser.Math.DegToRad(45), false);
            g.strokePath();

            // Стрелка
            g.lineStyle(2, 0xFFFFFF, 1);
            g.beginPath();
            g.moveTo(0,0);
            const angle = isActive ? -45 : 135; 
            const rad = Phaser.Math.DegToRad(angle);
            g.lineTo(Math.cos(rad)*12, Math.sin(rad)*12);
            g.strokePath();

            c.add(g);
            this.livesGroup.add(c);
        }
    }

    updateLevelText() {
        const lvlStr = this.level.toString().padStart(3, '0');
        this.levelText.setText(`PRESSURE-LVL: ${lvlStr}`);
    }

    restartGame() {
        this.level = 1;
        this.lives = 3;
        this.gridSize = 3;
        this.tilesToMemorize = 3;
        this.updateLivesUI();
        this.updateLevelText();
        this.hideOverlay();
        this.startLevel();
    }

    showOverlay(title, subtitle) {
        this.overlayText.setText(title);
        this.overlaySubText.setText(subtitle);
        this.overlay.setVisible(true);
        this.overlay.setAlpha(0);
        this.tweens.add({
            targets: this.overlay,
            alpha: 1,
            duration: 300
        });
    }

    hideOverlay() {
        this.tweens.add({
            targets: this.overlay,
            alpha: 0,
            duration: 300,
            onComplete: () => {
                this.overlay.setVisible(false);
            }
        });
    }

    startLevel() {
        if (this.grid) {
            this.grid.forEach(t => t.destroy());
        }
        this.grid = [];
        this.sequence = [];
        this.playerSequence = [];
        this.isInputActive = false;

        const headerHeight = 150; 
        const padding = 20;
        const availableWidth = this.scale.width - (padding * 2);
        const availableHeight = this.scale.height - headerHeight - padding;

        let gap = this.baseTileGap;
        if (this.gridSize > 5) gap = 8;

        const totalGap = gap * (this.gridSize - 1);
        const maxTileWidth = (availableWidth - totalGap) / this.gridSize;
        const maxTileHeight = (availableHeight - totalGap) / this.gridSize;
        let actualTileSize = Math.min(this.baseTileSize, maxTileWidth, maxTileHeight);
        
        const totalGridSizePx = (actualTileSize * this.gridSize) + (gap * (this.gridSize - 1));
        const startX = (this.scale.width - totalGridSizePx) / 2 + actualTileSize / 2;
        const startY = headerHeight + (availableHeight - totalGridSizePx) / 2 + actualTileSize / 2;

        let idCounter = 0;
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                const x = startX + col * (actualTileSize + gap);
                const y = startY + row * (actualTileSize + gap);

                const tile = this.add.container(x, y);
                const bg = this.add.graphics();
                
                // --- ИЗМЕНЕНИЕ 1: ПО УМОЛЧАНИЮ РИСУЕМ ЗАГЛУШКУ (BLIND) ---
                this.drawNozzle(bg, actualTileSize, 'blind'); 
                
                tile.add(bg);

                const zone = this.add.zone(0, 0, actualTileSize, actualTileSize).setRectangleDropZone(actualTileSize, actualTileSize);
                zone.setInteractive();
                tile.add(zone);

                tile.setData('id', idCounter);
                tile.setData('size', actualTileSize);
                tile.setData('bg', bg);
                
                zone.on('pointerdown', () => this.handleTileClick(tile));
                
                this.grid.push(tile);
                idCounter++;
            }
        }
        
        if (!this.overlay.visible) {
            this.nextTurn();
        }
    }

    /**
     * ОТРИСОВКА ПАТРУБКА
     * states: 'blind' (закрыт), 'open' (открыт), 'preview' (желтый открыт), 'success_open' (зеленый открыт), 'error' (красный закрыт)
     */
    drawNozzle(graphics, size, state = 'blind') {
        graphics.clear();
        const r = size / 2;
        
        // 1. Внешний край фланца
        let rimColor = COLORS.flangeRim;
        if (state === 'success_open') rimColor = COLORS.success; // Зеленая кромка при победе
        if (state === 'preview') rimColor = COLORS.highlight;    // Желтая кромка при показе

        graphics.fillStyle(rimColor, 1);
        graphics.fillCircle(0, 0, r);
        
        // Тень внешнего кольца
        graphics.lineStyle(2, 0x000000, 0.5);
        graphics.strokeCircle(0, 0, r);

        // 2. Отверстия под болты
        const boltRadius = r * 0.8;
        const numBolts = 8;
        graphics.fillStyle(0x0f172a, 0.8); 
        for(let i=0; i<numBolts; i++) {
            const angle = Phaser.Math.DegToRad(i * (360/numBolts));
            const bx = Math.cos(angle) * boltRadius;
            const by = Math.sin(angle) * boltRadius;
            graphics.fillCircle(bx, by, size * 0.04);
        }

        // Логика отрисовки: ОТКРЫТ ИЛИ ЗАКРЫТ
        const isOpenType = (state === 'open' || state === 'preview' || state === 'success_open');

        if (isOpenType) {
            // --- ОТКРЫТЫЙ (ДЫРА) ---
            const holeR = r * 0.6;
            
            // Градиент глубины
            graphics.fillStyle(0x000000, 1);
            graphics.fillCircle(0, 0, holeR);
            graphics.fillStyle(0x0f172a, 1);
            graphics.fillCircle(0, 0, holeR * 0.8);
            
            // Внутренний блик
            graphics.lineStyle(2, 0x94a3b8, 0.3);
            graphics.strokeCircle(0, 0, holeR);
            
            // Свечение из трубы для превью
            if (state === 'preview') {
                graphics.fillStyle(COLORS.highlight, 0.2);
                graphics.fillCircle(0, 0, holeR * 0.6);
            }

        } else {
            // --- ЗАКРЫТЫЙ (ЗАГЛУШКА) ---
            const blindR = r * 0.95;
            
            let faceColor = COLORS.blindFace;
            let boltColor = COLORS.blindBolt;

            if (state === 'error') {
                faceColor = COLORS.error; // Красная заглушка
                boltColor = 0x500000;
            }

            // Пластина
            graphics.fillStyle(faceColor, 1);
            graphics.fillCircle(0, 0, blindR);
            
            // Блик
            graphics.lineStyle(2, 0xffffff, 0.3);
            graphics.beginPath();
            graphics.arc(0, 0, blindR * 0.9, Phaser.Math.DegToRad(180), Phaser.Math.DegToRad(270));
            graphics.strokePath();

            // Болты
            graphics.fillStyle(boltColor, 1);
            graphics.lineStyle(1, 0x000000, 0.5);
            
            for(let i=0; i<numBolts; i++) {
                const angle = Phaser.Math.DegToRad(i * (360/numBolts));
                const bx = Math.cos(angle) * boltRadius;
                const by = Math.sin(angle) * boltRadius;
                graphics.fillCircle(bx, by, size * 0.06);
                graphics.strokeCircle(bx, by, size * 0.06);
            }
        }
    }

    nextTurn() {
        this.isInputActive = false;
        
        const totalTiles = this.grid.length;
        const indices = Array.from({length: totalTiles}, (_, i) => i);
        
        Phaser.Utils.Array.Shuffle(indices);
        this.sequence = indices.slice(0, this.tilesToMemorize);
        
        this.time.delayedCall(800, () => {
            this.playSequenceAnimation();
        });
    }

    playSequenceAnimation() {
        // --- ИЗМЕНЕНИЕ 2: АНИМАЦИЯ ОТКРЫТИЯ ---
        this.sequence.forEach((id) => {
            const tile = this.grid[id];
            const bg = tile.getData('bg');
            const size = tile.getData('size');

            // Анимация "Исчезновения" заглушки (Открытие)
            this.tweens.add({
                targets: tile,
                scaleX: 1.05,
                scaleY: 1.05,
                duration: 200,
                yoyo: true,
                onStart: () => {
                    // Рисуем открытый патрубок с подсветкой (preview)
                    this.drawNozzle(bg, size, 'preview');
                },
                onComplete: () => {
                    // Цвет вернется при закрытии
                }
            });
        });

        const viewTime = 1000 + (this.level * 200);
        
        this.time.delayedCall(viewTime, () => {
            // --- ИЗМЕНЕНИЕ 3: ВСЕ ОБРАТНО ЗАКРЫВАЕМ ---
            this.sequence.forEach((id) => {
                const tile = this.grid[id];
                const bg = tile.getData('bg');
                const size = tile.getData('size');
                
                // Возвращаем заглушку на место
                this.drawNozzle(bg, size, 'blind');
                
                // Звук удара металла (визуально трясем)
                this.tweens.add({
                    targets: tile,
                    scaleX: 1, 
                    duration: 100
                });
            });

            this.isInputActive = true;
            this.playerSequence = [];
        });
    }

    handleTileClick(tile) {
        if (!this.isInputActive) return;

        const id = tile.getData('id');
        const bg = tile.getData('bg');
        const size = tile.getData('size');

        // Нельзя нажать дважды
        if (this.playerSequence.includes(id)) return;

        if (this.sequence.includes(id)) {
            // ПРАВИЛЬНО: ОТКРЫВАЕМ КЛАПАН
            this.playerSequence.push(id);
            
            // Анимация вращения болтов/снятия крышки
            this.tweens.add({
                targets: tile,
                angle: 90, // Крутим крышку
                scaleX: 0.8, // Она уменьшается (улетает)
                scaleY: 0.8,
                duration: 150,
                onComplete: () => {
                    tile.setAngle(0);
                    tile.setScale(1);
                    // Рисуем открытое отверстие
                    this.drawNozzle(bg, size, 'open');
                }
            });

            if (this.playerSequence.length === this.sequence.length) {
                this.isInputActive = false;
                this.handleLevelComplete();
            }

        } else {
            // ОШИБКА: Пытаемся открыть не тот клапан (он заедает/краснеет)
            this.isInputActive = false;
            
            // Рисуем красную заглушку (Error)
            this.drawNozzle(bg, size, 'error');

            this.cameras.main.shake(200, 0.01);
            this.revealMissedTiles();

            this.time.delayedCall(1200, () => {
                this.lives--;
                this.updateLivesUI();
                
                if (this.lives > 0) {
                    this.startLevel(); 
                } else {
                    this.showOverlay("CRITICAL PRESSURE", `SYSTEM FAILURE AT LVL-${this.level}`);
                }
            });
        }
    }

    revealMissedTiles() {
        this.sequence.forEach(id => {
            if (!this.playerSequence.includes(id)) {
                const tile = this.grid[id];
                const bg = tile.getData('bg');
                const size = tile.getData('size');
                
                // Показываем, какие должны были быть открыты (желтые)
                this.drawNozzle(bg, size, 'preview');
                tile.setAlpha(0.6);
            }
        });
    }

    handleLevelComplete() {
        this.time.delayedCall(400, () => {
            // Все открытые клапаны становятся зелеными (Безопасно)
            this.sequence.forEach(id => {
                 const tile = this.grid[id];
                 const bg = tile.getData('bg');
                 const size = tile.getData('size');
                 this.drawNozzle(bg, size, 'success_open');
            });
            
            this.level++;
            this.updateLevelText();
            this.adjustDifficulty();
            
            this.time.delayedCall(800, () => {
                this.startLevel();
            });
        });
    }

    adjustDifficulty() {
        if (this.level % 2 === 0) {
            this.tilesToMemorize++;
        }
        if (this.level % 3 === 0 && this.gridSize < 9) {
            this.gridSize++;
        }
        const total = this.gridSize * this.gridSize;
        if (this.tilesToMemorize > total / 2) {
            this.tilesToMemorize = Math.floor(total / 2);
        }
    }
}

const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    parent: 'game-container',
    backgroundColor: '#0f172a',
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    scene: MainScene
};

const game = new Phaser.Game(config);

window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
