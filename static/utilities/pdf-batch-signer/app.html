<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PDF Batch Signer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Caveat:wght@600&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../../vendor/tailwind.min.css" />
    <script src="../../vendor/pdf-lib.min.js"></script>
    <script src="../../vendor/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
      if (window.pdfjsLib) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = '../../vendor/pdf.worker.min.js';
      }
    </script>
    <style>
      :root {
        font-family: 'Space Grotesk', 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: radial-gradient(circle at 20% 20%, rgba(99, 102, 241, 0.16), transparent 35%),
          radial-gradient(circle at 80% 10%, rgba(34, 211, 238, 0.16), transparent 32%),
          linear-gradient(135deg, #0b1224, #0b162c);
        color: #e4e8f5;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        padding: 28px 22px 48px;
      }
      .app-shell {
        max-width: 1260px;
        margin: 0 auto;
        backdrop-filter: blur(8px);
      }
      .glass {
        background: rgba(12, 18, 40, 0.72);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 20px 60px rgba(4, 6, 14, 0.65);
        border-radius: 22px;
      }
      .grid {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 18px;
        align-items: stretch;
      }
      @media (max-width: 1100px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        color: #e4e8f5;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-size: 11px;
      }
      .tag {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 12px;
        color: #b8c1ec;
      }
      .header {
        margin-bottom: 16px;
        display: flex;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }
      .header h1 {
        margin: 6px 0 4px;
        font-size: clamp(1.8rem, 3vw, 2.3rem);
        letter-spacing: -0.02em;
      }
      .header p {
        margin: 0;
        color: #94a3c6;
        max-width: 640px;
        line-height: 1.5;
      }
      .panel {
        padding: 18px;
      }
      .divider {
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.12), transparent);
        margin: 12px 0;
      }
      .chip {
        font-size: 12px;
        letter-spacing: 0.1em;
        color: #9aa7d7;
      }
      .drop-zone {
        border: 1px dashed rgba(255, 255, 255, 0.16);
        border-radius: 16px;
        padding: 14px;
        background: linear-gradient(135deg, rgba(94, 234, 212, 0.08), rgba(59, 130, 246, 0.06));
        transition: all 0.15s ease;
      }
      .drop-zone.is-hovered {
        border-color: #67e8f9;
        box-shadow: 0 12px 28px rgba(46, 204, 255, 0.22);
        transform: translateY(-1px);
      }
      .btn {
        border: none;
        border-radius: 12px;
        padding: 12px 14px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.18s ease;
        display: inline-flex;
        align-items: center;
        gap: 10px;
      }
      .btn-primary {
        background: linear-gradient(135deg, #3b82f6, #60a5fa);
        color: #0b1120;
      }
      .btn-primary:hover {
        box-shadow: 0 14px 32px rgba(59, 130, 246, 0.32);
        transform: translateY(-1px);
      }
      .btn-ghost {
        background: rgba(255, 255, 255, 0.08);
        color: #e4e8f5;
      }
      .btn-ghost:hover {
        background: rgba(255, 255, 255, 0.14);
      }
      .btn[disabled] {
        opacity: 0.45;
        cursor: not-allowed;
        box-shadow: none;
      }
      .list-tile {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        padding: 12px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        background: rgba(255, 255, 255, 0.02);
        transition: border 0.15s ease, background 0.15s ease;
      }
      .list-tile.is-active {
        border-color: rgba(94, 234, 212, 0.5);
        background: rgba(94, 234, 212, 0.06);
      }
      .status {
        font-size: 12px;
        color: #9aa7d7;
      }
      .status.success {
        color: #6ee7b7;
      }
      .status.warn {
        color: #fcd34d;
      }
      .status.error {
        color: #fda4af;
      }
      .stage {
        position: relative;
        background: radial-gradient(circle at 10% 10%, rgba(59, 130, 246, 0.08), transparent 50%),
          rgba(6, 10, 22, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 16px;
        padding: 12px;
        min-height: 520px;
        overflow: hidden;
      }
      .canvas-wrap {
        position: relative;
        overflow: auto;
        max-height: 78vh;
        display: flex;
        justify-content: center;
      }
      canvas {
        display: block;
      }
      .sig-box {
        position: absolute;
        border: 2px dashed rgba(94, 234, 212, 0.9);
        background: rgba(94, 234, 212, 0.08);
        backdrop-filter: blur(2px);
        cursor: move;
        user-select: none;
      }
      .sig-handle {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 2px solid #0b1224;
        background: #67e8f9;
        position: absolute;
        right: -9px;
        bottom: -9px;
        cursor: se-resize;
      }
      .sig-preview {
        border-radius: 10px;
        border: 1px dashed rgba(255, 255, 255, 0.12);
        padding: 10px;
        min-height: 120px;
        display: grid;
        place-items: center;
        background: rgba(255, 255, 255, 0.03);
      }
      .tab-group {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
      }
      .tab-btn {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.04);
        color: #cbd5f5;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s ease;
      }
      .tab-btn.is-active {
        border-color: rgba(94, 234, 212, 0.6);
        background: rgba(94, 234, 212, 0.08);
        color: #e4e8f5;
      }
      .floating-status {
        position: fixed;
        bottom: 18px;
        right: 18px;
        padding: 12px 14px;
        border-radius: 12px;
        background: rgba(12, 18, 40, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        color: #e4e8f5;
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 20;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        font-size: 11px;
        background: #60a5fa;
        color: #0b1120;
        font-weight: 700;
      }
      .muted {
        color: #94a3c6;
        font-size: 14px;
      }
      .input {
        width: 100%;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.04);
        color: #e4e8f5;
        padding: 10px 12px;
        font-size: 14px;
      }
      .input:focus {
        outline: 2px solid rgba(94, 234, 212, 0.5);
        border-color: rgba(94, 234, 212, 0.8);
      }
      .banner {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(59, 130, 246, 0.08);
        border: 1px solid rgba(59, 130, 246, 0.35);
        color: #dbeafe;
      }
      .banner strong {
        color: #fff;
      }
      .empty-state {
        color: #94a3c6;
        text-align: center;
        padding: 30px 10px;
        border: 1px dashed rgba(255, 255, 255, 0.1);
        border-radius: 12px;
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <div class="header">
        <div>
          <div class="pill">PDF pipeline</div>
          <h1>PDF Batch Signer</h1>
          <p>
            Drop a stack of drawings, design a signature once, and stamp every page in one pass. Files stay in your
            browser; use optional Gemini analysis to pre-fill title blocks.
          </p>
        </div>
        <div class="tag">Local-first / WebAssembly PDF / React</div>
      </div>

      <div id="app"></div>
    </div>
    <script type="module">
  import React, {useEffect, useMemo, useRef, useState} from "https://esm.sh/react@18.3.1";
  import {createRoot} from "https://esm.sh/react-dom@18.3.1/client";
  import htm from "https://esm.sh/htm@3.1.1";
  const html = htm.bind(React.createElement);

  const {PDFDocument} = window.PDFLib;
  const JSZip = window.JSZip;

  const generateId = () => (crypto.randomUUID ? crypto.randomUUID() : `id-${Date.now()}-${Math.random().toString(16).slice(2)}`);

  const usePersistentState = (key, fallback) => {
    const [value, setValue] = useState(() => {
      try {
        const stored = localStorage.getItem(key);
        if (stored !== null) return JSON.parse(stored);
      } catch (err) {
        console.warn('Local storage unavailable', err);
      }
      return fallback;
    });
    useEffect(() => {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch (err) {
        console.warn('Local storage unavailable', err);
      }
    }, [key, value]);
    return [value, setValue];
  };

  const SignaturePad = ({mode, onChange}) => {
    const canvasRef = useRef(null);
    const [isDrawing, setIsDrawing] = useState(false);
    const [color, setColor] = useState('#0ea5e9');
    const [text, setText] = useState('QA Approved');

    useEffect(() => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.lineWidth = 2.4;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = color;
    }, [color]);

    const emitFromCanvas = () => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      onChange(canvas.toDataURL('image/png'));
    };

    const handlePointerDown = (event) => {
      if (mode !== 'draw') return;
      const canvas = canvasRef.current;
      if (!canvas) return;
      const rect = canvas.getBoundingClientRect();
      const ctx = canvas.getContext('2d');
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(event.clientX - rect.left, event.clientY - rect.top);
      setIsDrawing(true);
    };

    const handlePointerMove = (event) => {
      if (!isDrawing || mode !== 'draw') return;
      const canvas = canvasRef.current;
      if (!canvas) return;
      const rect = canvas.getBoundingClientRect();
      const ctx = canvas.getContext('2d');
      ctx.lineTo(event.clientX - rect.left, event.clientY - rect.top);
      ctx.stroke();
    };

    const handlePointerUp = () => {
      if (!isDrawing) return;
      setIsDrawing(false);
      emitFromCanvas();
    };

    const clear = () => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      onChange(null);
    };

    useEffect(() => {
      if (mode !== 'text') return;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const size = 48;
      const padding = 22;
      ctx.font = `${size}px "Caveat", "Space Grotesk", system-ui`;
      const metrics = ctx.measureText(text || '');
      canvas.width = Math.max(metrics.width + padding * 2, 260);
      canvas.height = size + padding * 2;
      ctx.font = `${size}px "Caveat", "Space Grotesk", system-ui`;
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text || '', canvas.width / 2, canvas.height / 2);
      onChange(text ? canvas.toDataURL('image/png') : null);
    }, [mode, text, color, onChange]);

    const handleUpload = (event) => {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => onChange(reader.result);
      reader.readAsDataURL(file);
    };

    return html`<div className="space-y-3">
      ${mode === 'draw' && html`<div>
        <div className="sig-preview">
          <canvas
            ref=${canvasRef}
            width="420"
            height="180"
            onPointerDown=${handlePointerDown}
            onPointerMove=${handlePointerMove}
            onPointerUp=${handlePointerUp}
            onPointerLeave=${handlePointerUp}
            style=${{width: '100%', height: '180px', touchAction: 'none'}}
          ></canvas>
        </div>
        <div className="flex items-center justify-between mt-2 gap-2">
          <label className="flex items-center gap-2 text-sm text-slate-300">
            Ink
            <input type="color" value=${color} onChange=${(e) => setColor(e.target.value)} aria-label="Signature color" />
          </label>
          <button className="btn btn-ghost text-sm px-3 py-2" type="button" onClick=${clear}>Clear pad</button>
        </div>
      </div>`}

      ${mode === 'text' && html`<div className="space-y-3">
        <input
          className="input"
          placeholder="Type the signer name or initials"
          value=${text}
          onChange=${(e) => setText(e.target.value)}
        />
        <label className="flex items-center gap-2 text-sm text-slate-300">
          Ink
          <input type="color" value=${color} onChange=${(e) => setColor(e.target.value)} aria-label="Signature color" />
        </label>
        <div className="sig-preview text-center text-slate-400">
          <span className="chip">Live preview</span>
        </div>
      </div>`}

      ${mode === 'image' && html`<label className="sig-preview cursor-pointer border border-dashed border-slate-600 hover:border-slate-400 transition">
        <input type="file" accept="image/png,image/jpeg" hidden onChange=${handleUpload} />
        <div className="text-sm text-slate-300">Upload a scanned signature (PNG/JPG)</div>
      </label>`}
    </div>`;
  };

  const FileList = ({files, activeId, onAdd, onSelect, onRemove, onAnalyze, geminiKey, setGeminiKey, analyzing}) => {
    const inputRef = useRef(null);
    const dropRef = useRef(null);

    const handleFiles = (list) => {
      const pdfs = Array.from(list || []).filter((file) => file.type === 'application/pdf');
      if (!pdfs.length) return;
      onAdd(pdfs);
    };

    useEffect(() => {
      const node = dropRef.current;
      if (!node) return;
      const onDragOver = (event) => {
        event.preventDefault();
        node.classList.add('is-hovered');
      };
      const onLeave = (event) => {
        event.preventDefault();
        node.classList.remove('is-hovered');
      };
      const onDrop = (event) => {
        event.preventDefault();
        node.classList.remove('is-hovered');
        if (event.dataTransfer?.files?.length) {
          handleFiles(event.dataTransfer.files);
        }
      };
      node.addEventListener('dragover', onDragOver);
      node.addEventListener('dragenter', onDragOver);
      node.addEventListener('dragleave', onLeave);
      node.addEventListener('drop', onDrop);
      return () => {
        node.removeEventListener('dragover', onDragOver);
        node.removeEventListener('dragenter', onDragOver);
        node.removeEventListener('dragleave', onLeave);
        node.removeEventListener('drop', onDrop);
      };
    }, []);

    return html`<div className="glass panel space-y-4">
      <div className="flex items-center justify-between gap-2">
        <div>
          <div className="chip">Step 1</div>
          <h2 className="text-xl font-semibold mt-1 mb-0">Load drawings</h2>
        </div>
        <button className="btn btn-ghost text-sm" type="button" onClick=${() => inputRef.current?.click()}>
          Browse PDFs
        </button>
        <input
          ref=${inputRef}
          type="file"
          accept="application/pdf"
          multiple
          hidden
          onChange=${(e) => handleFiles(e.target.files)}
        />
      </div>

      <div ref=${dropRef} className="drop-zone">
        <div className="flex items-center gap-3">
          <div className="badge">+</div>
          <div>
            <div className="text-lg font-semibold">Drop PDF files</div>
            <div className="muted">We keep everything client-side.</div>
          </div>
        </div>
      </div>

      <div className="space-y-2 max-h-64 overflow-y-auto pr-1">
        ${files.length === 0 && html`<div className="muted text-sm">Nothing loaded yet.</div>`}
        ${files.map(
          (file) => html`<div
            key=${file.id}
            className=${`list-tile ${activeId === file.id ? 'is-active' : ''}`}
            onClick=${() => onSelect(file.id)}
          >
            <div>
              <div className="font-semibold">${file.name}</div>
              <div className="status flex items-center gap-2">
                ${file.meta.status === 'done' && html`<span className="status success">Title: ${file.meta.title || '-'}</span>`}
                ${file.meta.status === 'analyzing' && html`<span className="status warn">Analyzing...</span>`}
                ${file.meta.status === 'error' && html`<span className="status error">Analysis failed</span>`}
                ${file.meta.status === 'pending' && html`<span className="status">Pending</span>`}
              </div>
            </div>
            <button
              className="btn btn-ghost text-xs px-3 py-2"
              type="button"
              onClick=${(event) => {
                event.stopPropagation();
                onRemove(file.id);
              }}
            >
              Remove
            </button>
          </div>`,
        )}
      </div>

      <div className="divider"></div>

      <div className="space-y-3">
        <div className="flex items-center justify-between gap-2">
          <div>
            <div className="chip">Optional</div>
            <p className="muted mb-0">Use Gemini to prefill drawing title and number.</p>
          </div>
          <button className="btn btn-primary text-sm" type="button" onClick=${onAnalyze} disabled=${analyzing || files.length === 0}>
            ${analyzing ? 'Analyzing...' : 'Run analysis'}
          </button>
        </div>
        <input
          className="input"
          placeholder="Gemini API key (stored locally)"
          value=${geminiKey}
          onChange=${(e) => setGeminiKey(e.target.value)}
        />
      </div>
    </div>`;
  };

  const PdfStage = ({file, signature, box, setBox, setCanvasSize}) => {
    const canvasRef = useRef(null);
    const containerRef = useRef(null);
    const dragRef = useRef(null);

    useEffect(() => {
      let cancelled = false;
      const render = async () => {
        if (!file) return;
        const arrayBuffer = await file.arrayBuffer();
        const loadingTask = window.pdfjsLib.getDocument({data: arrayBuffer});
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({scale: 1.35});
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        setCanvasSize({width: viewport.width, height: viewport.height});
        await page.render({canvasContext: ctx, viewport}).promise;
        if (cancelled) return;
      };
      render();
      return () => {
        cancelled = true;
      };
    }, [file, setCanvasSize]);

    useEffect(() => {
      const handleMove = (event) => {
        if (!dragRef.current) return;
        const {mode, startX, startY, startBox} = dragRef.current;
        const rect = containerRef.current.getBoundingClientRect();
        const dx = event.clientX - startX;
        const dy = event.clientY - startY;
        let next = {...startBox};
        if (mode === 'move') {
          next.x = startBox.x + dx;
          next.y = startBox.y + dy;
        } else if (mode === 'resize') {
          next.width = Math.max(40, startBox.width + dx);
          next.height = Math.max(30, startBox.height + dy);
        }
        const maxX = Math.max(0, rect.width - next.width);
        const maxY = Math.max(0, rect.height - next.height);
        next.x = Math.min(Math.max(0, next.x), maxX);
        next.y = Math.min(Math.max(0, next.y), maxY);
        setBox(next);
      };

      const handleUp = () => {
        dragRef.current = null;
        window.removeEventListener('pointermove', handleMove);
        window.removeEventListener('pointerup', handleUp);
      };

      if (dragRef.current) {
        window.addEventListener('pointermove', handleMove);
        window.addEventListener('pointerup', handleUp);
      }

      return () => {
        window.removeEventListener('pointermove', handleMove);
        window.removeEventListener('pointerup', handleUp);
      };
    }, [setBox]);

    const startDrag = (mode) => (event) => {
      event.preventDefault();
      dragRef.current = {
        mode,
        startX: event.clientX,
        startY: event.clientY,
        startBox: {...box},
      };
    };

    return html`<div className="stage">
      <div className="flex items-center justify-between mb-3">
        <div>
          <div className="chip">Step 3</div>
          <h2 className="text-lg font-semibold mb-0">Position signature</h2>
        </div>
        <div className="text-sm text-slate-300">
          <span className="badge">${signature ? 'OK' : '--'}</span> ${signature ? 'Ready to apply' : 'Add a signature first'}
        </div>
      </div>
      <div ref=${containerRef} className="canvas-wrap">
        ${file
          ? html`<${React.Fragment}>
              <canvas ref=${canvasRef}></canvas>
              ${signature && html`<div
                className="sig-box"
                style=${{
                  left: box.x + 'px',
                  top: box.y + 'px',
                  width: box.width + 'px',
                  height: box.height + 'px',
                }}
                onPointerDown=${startDrag('move')}
              >
                <img
                  src=${signature}
                  alt="Signature preview"
                  style=${{width: '100%', height: '100%', objectFit: 'contain', pointerEvents: 'none'}}
                />
                <div className="sig-handle" onPointerDown=${startDrag('resize')}></div>
              </div>`}
            </${React.Fragment}>`
          : html`<div className="empty-state">Load a PDF to see the first page preview.</div>`}
      </div>
    </div>`;
  };

  const SigningPanel = ({mode, setMode, signature, setSignature}) => {
    return html`<div className="glass panel space-y-4">
      <div className="flex items-center justify-between">
        <div>
          <div className="chip">Step 2</div>
          <h2 className="text-xl font-semibold mt-1 mb-0">Design signature</h2>
        </div>
        <div className="text-sm text-slate-300">${signature ? 'Saved locally' : 'No signature yet'}</div>
      </div>
      <div className="tab-group">
        ${['draw', 'text', 'image'].map(
          (key) => html`<button
            key=${key}
            type="button"
            className=${`tab-btn ${mode === key ? 'is-active' : ''}`}
            onClick=${() => setMode(key)}
          >
            ${key === 'draw' ? 'Sketch' : key === 'text' ? 'Typed' : 'Upload'}
          </button>`,
        )}
      </div>
      <${SignaturePad} mode=${mode} onChange=${(data) => setSignature(data)} />
      <div className="sig-preview">
        ${signature
          ? html`<img src=${signature} alt="Signature preview" style=${{maxWidth: '100%', maxHeight: '140px', objectFit: 'contain'}} />`
          : html`<div className="muted">Your signature preview appears here.</div>`}
      </div>
    </div>`;
  };

  const App = () => {
    const [files, setFiles] = useState([]);
    const [activeId, setActiveId] = useState(null);
    const [signature, setSignature] = usePersistentState('pdf-batch-signer-signature', null);
    const [sigMode, setSigMode] = useState('draw');
    const [box, setBox] = useState({x: 120, y: 160, width: 220, height: 90});
    const [canvasSize, setCanvasSize] = useState({width: 0, height: 0});
    const [isSigning, setIsSigning] = useState(false);
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [geminiKey, setGeminiKey] = usePersistentState('pdf-batch-signer-gemini-key', '');
    const [status, setStatus] = useState('Waiting for files');

    const selectedFile = useMemo(() => files.find((f) => f.id === activeId) || files[0] || null, [files, activeId]);
    const canSign = files.length > 0 && !!signature && canvasSize.width > 0 && canvasSize.height > 0;

    const addFiles = (fileList) => {
      const entries = fileList.map((file) => ({
        id: generateId(),
        file,
        name: file.name,
        meta: {title: '', drawingNumber: '', status: 'pending'},
      }));
      setFiles((prev) => {
        const merged = [...prev, ...entries];
        if (!activeId && merged.length) setActiveId(merged[0].id);
        return merged;
      });
      setStatus('Loaded ' + entries.length + ' file(s).');
    };

    const removeFile = (id) => {
      setFiles((prev) => prev.filter((f) => f.id !== id));
      setActiveId((current) => (current === id ? null : current));
    };

    const runAnalysis = async () => {
      if (!geminiKey) {
        setStatus('Add a Gemini API key to run analysis.');
        return;
      }
      if (!files.length) return;
      setIsAnalyzing(true);
      setStatus('Analyzing title blocks with Gemini...');

      const prompt =
        'Extract the drawing title and drawing number from this PDF page. Return JSON with keys "title" and "drawingNumber". Keep it short.';

      const renderPageAsPng = async (file) => {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await window.pdfjsLib.getDocument({data: arrayBuffer}).promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({scale: 1.1});
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({canvasContext: ctx, viewport}).promise;
        return canvas.toDataURL('image/png').split(',')[1];
      };

      const parseJson = (text) => {
        try {
          const trimmed = text.trim();
          const start = trimmed.indexOf('{');
          const end = trimmed.lastIndexOf('}');
          if (start !== -1 && end !== -1) {
            return JSON.parse(trimmed.slice(start, end + 1));
          }
          return JSON.parse(trimmed);
        } catch {
          return {title: '', drawingNumber: ''};
        }
      };

      for (const file of files) {
        setFiles((prev) => prev.map((entry) => (entry.id === file.id ? {...entry, meta: {...entry.meta, status: 'analyzing'}} : entry)));
        try {
          const base64 = await renderPageAsPng(file.file);
          const response = await fetch(
            'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=' + geminiKey,
            {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({
                contents: [{parts: [{inlineData: {mimeType: 'image/png', data: base64}}, {text: prompt}]}],
                generationConfig: {responseMimeType: 'application/json'},
              }),
            },
          );
          const payload = await response.json();
          const text = payload?.candidates?.[0]?.content?.parts?.map((p) => p.text || '').join('') || JSON.stringify(payload);
          const parsed = parseJson(text);
          setFiles((prev) =>
            prev.map((entry) =>
              entry.id === file.id
                ? {
                    ...entry,
                    meta: {
                      title: parsed.title || '',
                      drawingNumber: parsed.drawingNumber || '',
                      status: 'done',
                    },
                  }
                : entry,
            ),
          );
        } catch (error) {
          console.error(error);
          setFiles((prev) =>
            prev.map((entry) =>
              entry.id === file.id
                ? {
                    ...entry,
                    meta: {...entry.meta, status: 'error'},
                  }
                : entry,
            ),
          );
        }
      }
      setIsAnalyzing(false);
      setStatus('Analysis complete.');
    };

    const signAll = async () => {
      if (!canSign) {
        setStatus('Add files and a signature before signing.');
        return;
      }
      setIsSigning(true);
      setStatus('Stamping pages and building ZIP...');
      const zip = new JSZip();
      const isPng = signature.startsWith('data:image/png');

      for (const entry of files) {
        const pdfDoc = await PDFDocument.load(await entry.file.arrayBuffer());
        const sigImage = isPng ? await pdfDoc.embedPng(signature) : await pdfDoc.embedJpg(signature);
        const pages = pdfDoc.getPages();
        for (const page of pages) {
          const {width: pageW, height: pageH} = page.getSize();
          const scaleX = pageW / (canvasSize.width || 1);
          const scaleY = pageH / (canvasSize.height || 1);
          const pdfX = box.x * scaleX;
          const pdfY = pageH - (box.y + box.height) * scaleY;
          const pdfW = box.width * scaleX;
          const pdfH = box.height * scaleY;
          page.drawImage(sigImage, {x: pdfX, y: pdfY, width: pdfW, height: pdfH});
        }
        const bytes = await pdfDoc.save();
        const filename = entry.name.replace(/\.pdf$/i, '') + '-signed.pdf';
        zip.file(filename, bytes);
      }

      const blob = await zip.generateAsync({type: 'blob'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'signed-drawings.zip';
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1200);
      setIsSigning(false);
      setStatus('ZIP ready. Check your downloads.');
    };

    return html`<${React.Fragment}>
      <div className="grid">
        <div className="space-y-3">
          <${FileList}
            files=${files}
            activeId=${selectedFile?.id || null}
            onAdd=${addFiles}
            onSelect=${setActiveId}
            onRemove=${removeFile}
            onAnalyze=${runAnalysis}
            geminiKey=${geminiKey}
            setGeminiKey=${setGeminiKey}
            analyzing=${isAnalyzing}
          />
          <${SigningPanel} mode=${sigMode} setMode=${setSigMode} signature=${signature} setSignature=${setSignature} />
          <div className="banner">
            <div className="badge">i</div>
            <div className="text-sm">
              <strong>Privacy:</strong> PDFs, signatures, and AI results stay in your browser. The Gemini call only runs if you provide a key.
            </div>
          </div>
        </div>

        <div className="space-y-3">
          <${PdfStage} file=${selectedFile?.file || null} signature=${signature} box=${box} setBox=${setBox} setCanvasSize=${setCanvasSize} />
          <div className="glass panel flex flex-wrap items-center justify-between gap-3">
            <div>
              <div className="chip">Finalize</div>
              <div className="text-sm text-slate-300">Applies the signature to every page across all PDFs.</div>
            </div>
            <div className="flex items-center gap-2">
              <button className="btn btn-ghost" type="button" onClick=${() => setBox({x: 120, y: 160, width: 220, height: 90})}>
                Reset placement
              </button>
              <button className="btn btn-primary" type="button" onClick=${signAll} disabled=${!canSign || isSigning || isAnalyzing}>
                ${isSigning ? 'Signing...' : 'Apply to all & download ZIP'}
              </button>
            </div>
          </div>
        </div>
      </div>

      <div className="floating-status">
        <div className="badge">${isSigning ? '!' : isAnalyzing ? 'AI' : 'i'}</div>
        <div className="text-sm">${status}</div>
      </div>
    </${React.Fragment}>`;
  };

  const root = createRoot(document.getElementById('app'));
  root.render(html`<${App} />`);
</script>

  </body>
</html>
