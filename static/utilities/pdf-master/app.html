<!DOCTYPE html>
<html lang="en">

<head>
  <script src="../../vendor/tailwindcss.js"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF Master</title>
  <script src="../../vendor/pdf-lib.min.js"></script>
  <script src="../../vendor/pdf.min.js"></script>
  <script>
    if (window['pdfjsLib']) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = '../../vendor/pdf.worker.min.js';
    }
  </script>
  <!-- Fonts removed -->
  <!-- <link rel="preconnect" href="https://fonts.googleapis.com" /> -->
  <style>
    :root {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #0f172a;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 15% 20%, rgba(66, 133, 244, 0.15), transparent 55%),
        linear-gradient(180deg, #f6f8ff, #f1f5ff);
      padding: 40px 20px 80px;
    }

    .workspace {
      max-width: 1100px;
      margin: 0 auto;
    }

    .hero {
      text-align: center;
      margin-bottom: 32px;
    }

    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.4em;
      color: #94a3d6;
      font-size: 0.75rem;
      margin-bottom: 12px;
    }

    .hero h1 {
      font-size: clamp(2rem, 5vw, 3rem);
      margin: 0;
    }

    .hero p {
      max-width: 640px;
      margin: 16px auto 0;
      color: #4f5977;
      line-height: 1.6;
    }

    .panel {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 32px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      box-shadow: 0 30px 60px rgba(15, 23, 42, 0.15);
      padding: 36px;
      margin-bottom: 32px;
    }

    .drop-zone {
      border: 2px dashed rgba(33, 92, 255, 0.3);
      border-radius: 28px;
      padding: 40px;
      text-align: center;
      background: linear-gradient(135deg, rgba(33, 92, 255, 0.08), rgba(255, 255, 255, 0.6));
      transition: border-color 0.2s ease, transform 0.2s ease, background 0.2s ease;
    }

    .drop-zone__icon {
      width: 72px;
      height: 72px;
      margin: 0 auto 16px;
      border-radius: 20px;
      background: #1a2d6d;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      box-shadow: 0 12px 30px rgba(26, 45, 109, 0.35);
    }

    .drop-zone h2 {
      margin: 0;
      font-size: 1.35rem;
    }

    .drop-zone p {
      margin: 12px 0 24px;
      color: #4f5977;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      justify-content: center;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 12px 26px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.18);
    }

    .btn.primary {
      background: linear-gradient(135deg, #215cff, #3f8bff);
      color: #fff;
    }

    .btn.secondary {
      background: #fff;
      color: #132043;
      border: 1px solid rgba(15, 23, 42, 0.12);
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 28px;
    }

    .status-row p {
      text-transform: uppercase;
      font-size: 0.78rem;
      letter-spacing: 0.2em;
      color: #7a82a1;
      margin: 0;
    }

    .view-toggle {
      display: inline-flex;
      border: 1px solid rgba(15, 23, 42, 0.1);
      border-radius: 999px;
      padding: 4px;
      gap: 4px;
      background: #f6f8ff;
      margin-top: 18px;
    }

    .view-toggle button {
      border: none;
      background: transparent;
      padding: 8px 18px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      color: #6c7392;
    }

    .view-toggle button.is-active {
      background: #0f172a;
      color: #fff;
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.25);
    }

    .btn.ghost {
      background: #17b27b;
      color: #fff;
    }

    .btn[disabled] {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }

    .page-list-empty {
      text-align: center;
      color: #7a82a1;
      padding: 60px 20px;
      border: 2px dashed rgba(15, 23, 42, 0.08);
      border-radius: 28px;
      background: rgba(255, 255, 255, 0.6);
    }

    .page-list {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .tile-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 18px;
    }

    .page-card {
      border-radius: 22px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      background: #fff;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.12);
      padding: 28px;
      margin-bottom: 24px;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .page-card.dragging {
      opacity: 0.7;
      transform: scale(0.99);
      box-shadow: 0 30px 60px rgba(15, 23, 42, 0.25);
    }

    .page-card__meta {
      display: flex;
      justify-content: space-between;
      gap: 18px;
      flex-wrap: wrap;
    }

    .page-card__details {
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
      align-items: flex-start;
    }

    .title {
      font-size: 1.05rem;
      font-weight: 600;
      margin: 0 0 4px;
    }

    .subtext {
      color: #6c7392;
      margin: 0;
    }

    .page-preview {
      width: 120px;
      height: 160px;
      border: 1px solid rgba(15, 23, 42, 0.12);
      border-radius: 16px;
      background: radial-gradient(circle at 20% 20%, rgba(33, 92, 255, 0.1), #f7f9ff);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      perspective: 1000px;
    }

    .page-preview img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: block;
    }

    .page-card__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 18px;
    }

    .chip {
      text-transform: uppercase;
      letter-spacing: 0.35em;
      font-size: 0.7rem;
      color: #9aa2bf;
      margin-bottom: 6px;
    }

    .btn.text {
      border-radius: 14px;
      padding: 10px 18px;
      font-size: 0.9rem;
      box-shadow: none;
    }

    .btn.text.rotate {
      border: 1px solid rgba(33, 92, 255, 0.3);
      color: #1c2f6a;
      background: rgba(33, 92, 255, 0.08);
    }

    .btn.text.danger {
      border: 1px solid rgba(255, 76, 115, 0.3);
      color: #b10b33;
      background: rgba(255, 76, 115, 0.08);
    }

    .btn.text.dark {
      background: #0f172a;
      color: #fff;
    }

    .tile-card {
      border-radius: 20px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      background: rgba(255, 255, 255, 0.96);
      padding: 16px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
      min-height: 240px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .tile-card.dragging {
      opacity: 0.75;
      transform: scale(0.98);
    }

    .tile-thumb {
      border-radius: 12px;
      border: 1px solid rgba(15, 23, 42, 0.12);
      background: #f9fbff;
      padding: 8px;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      perspective: 1000px;
    }

    .tile-thumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .tile-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tile-name {
      font-size: 0.95rem;
      font-weight: 600;
      margin: 0;
    }

    .tile-sub {
      font-size: 0.75rem;
      color: #7a82a1;
      margin: 0;
    }

    .tile-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .tile-actions .icon {
      border: none;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      box-shadow: 0 6px 15px rgba(15, 23, 42, 0.15);
      background: #fff;
      color: #1c2f6a;
    }

    .tile-actions .icon.rotate {
      background: #e0ebff;
      color: #1a48c4;
    }

    .tile-actions .icon.remove {
      background: #ffe2e7;
      color: #b31537;
    }

    .tile-actions a.icon {
      text-decoration: none;
      background: #0f172a;
      color: #fff;
    }

    .preview-face {
      width: 100%;
      height: 100%;
      border-radius: inherit;
      transform-style: preserve-3d;
    }

    .preview-plane {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.35s ease;
    }

    .preview-placeholder {
      font-size: 0.75rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: #9aa2bf;
    }

    .preview-face.is-flipping {
      animation: previewFlip 0.55s ease;
    }

    @keyframes previewFlip {
      0% {
        transform: rotateY(0deg);
      }

      50% {
        transform: rotateY(90deg) scale(0.94);
      }

      100% {
        transform: rotateY(0deg);
      }
    }

    #status-message {
      color: #7a82a1;
      font-size: 0.9rem;
      margin-top: 18px;
      min-height: 20px;
    }

    .drop-ready {
      border-color: #215cff !important;
      background: rgba(33, 92, 255, 0.1) !important;
      transform: translateY(-2px);
    }

    input[type='file'].sr-only {
      position: absolute;
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      z-index: -1;
    }
  </style>
</head>

<body>
  <div class="workspace">
    <header class="hero">
      <p class="eyebrow">PDF pipeline</p>
      <h1>PDF Master workspace</h1>
      <p>
        Merge submittals, drag sheets into the right sequence, rotate field sketches, and export a
        single PDF without uploading sensitive data.
      </p>
    </header>

    <section class="panel">
      <div id="drop-zone" class="drop-zone">
        <div class="drop-zone__icon">⬆</div>
        <h2>Drop PDFs here or choose files</h2>
        <p>Supports multi-upload and keeps everything on this device.</p>
        <div class="button-row">
          <button id="choose-files" class="btn primary">Select PDF files</button>
          <button id="clear-workspace" class="btn secondary">Clear workspace</button>
        </div>
        <input id="file-input" class="sr-only" type="file" accept="application/pdf" multiple />
      </div>
      <div class="status-row">
        <p id="page-counter">No pages loaded</p>
        <button id="merge-btn" class="btn ghost" disabled>Download merged PDF</button>
      </div>
      <div class="view-toggle" role="tablist" aria-label="Choose layout">
        <button type="button" data-view="list" class="is-active">Stacked view</button>
        <button type="button" data-view="tiles">Tile view</button>
      </div>
    </section>

    <section>
      <div id="page-list" class="page-list">
        <div class="page-list-empty">
          Drop PDFs to build a playlist of sheets. Drag entries to reorder, rotate them, and view
          the page in the native viewer.
        </div>
      </div>
    </section>

    <p id="status-message"></p>
  </div>

  <script>
    const fileInput = document.getElementById('file-input');
    const chooseButton = document.getElementById('choose-files');
    const clearButton = document.getElementById('clear-workspace');
    const dropZone = document.getElementById('drop-zone');
    const pageListEl = document.getElementById('page-list');
    const mergeButton = document.getElementById('merge-btn');
    const counterEl = document.getElementById('page-counter');
    const statusEl = document.getElementById('status-message');
    const viewButtons = document.querySelectorAll('[data-view]');
    const { PDFDocument, degrees } = PDFLib;

    const documents = new Map();
    const pagePreviews = new Map();
    let pages = [];
    let dragSourceId = null;
    let currentView = 'list';
    const pendingFlipIds = new Set();

    const viewStrategies = {
      list: createListCard,
      tiles: createTileCard,
    };

    function setView(mode) {
      currentView = mode;
      viewButtons.forEach((button) => {
        button.classList.toggle('is-active', button.dataset.view === currentView);
      });
      pageListEl.classList.toggle('tile-grid', currentView === 'tiles');
      renderPages();
    }
    viewButtons.forEach((button) => {
      button.addEventListener('click', () => {
        if (button.dataset.view !== currentView) {
          setView(button.dataset.view);
        }
      });
    });
    setView(currentView);

    function queuePreviewFlip(id) {
      pendingFlipIds.add(id);
    }

    function runPendingPreviewFlips() {
      pendingFlipIds.forEach((id) => {
        document.querySelectorAll(`[data-preview="${id}"]`).forEach((node) => {
          node.classList.add('is-flipping');
          setTimeout(() => {
            node.classList.remove('is-flipping');
          }, 500);
        });
      });
      pendingFlipIds.clear();
    }

    chooseButton.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (event) => {
      if (!event.target.files?.length) return;
      ingestFiles(event.target.files);
      event.target.value = '';
    });

    ['dragenter', 'dragover'].forEach((eventName) => {
      dropZone.addEventListener(eventName, (event) => {
        event.preventDefault();
        dropZone.classList.add('drop-ready');
      });
    });

    ['dragleave', 'drop'].forEach((eventName) => {
      dropZone.addEventListener(eventName, (event) => {
        event.preventDefault();
        if (eventName === 'drop' && event.dataTransfer?.files?.length) {
          ingestFiles(event.dataTransfer.files);
        }
        dropZone.classList.remove('drop-ready');
      });
    });

    clearButton.addEventListener('click', () => {
      pages = [];
      documents.forEach((doc) => URL.revokeObjectURL(doc.url));
      documents.clear();
      pagePreviews.clear();
      renderPages();
      statusEl.textContent = 'Workspace cleared.';
    });

    mergeButton.addEventListener('click', async () => {
      if (!pages.length) return;
      mergeButton.disabled = true;
      mergeButton.textContent = 'Preparing...';
      statusEl.textContent = 'Copying pages and building merged PDF...';
      try {
        const merged = await PDFDocument.create();
        for (const page of pages) {
          const source = await PDFDocument.load(documents.get(page.docId).bytes);
          const [copied] = await merged.copyPages(source, [page.pageIndex]);
          if (page.rotation) {
            copied.setRotation(degrees(page.rotation));
          }
          merged.addPage(copied);
        }
        const bytes = await merged.save();
        const blob = new Blob([bytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `pdf-master-${new Date().toISOString().slice(0, 10)}.pdf`;
        link.click();
        setTimeout(() => URL.revokeObjectURL(url), 1500);
        statusEl.textContent = 'Merged PDF generated successfully.';
      } catch (error) {
        console.error(error);
        statusEl.textContent = 'Something went wrong while merging the files.';
      } finally {
        mergeButton.disabled = !pages.length;
        mergeButton.textContent = 'Download merged PDF';
      }
    });

    function renderPages() {
      pageListEl.innerHTML = '';
      pageListEl.classList.toggle('tile-grid', currentView === 'tiles');
      mergeButton.disabled = !pages.length;
      if (!pages.length) {
        pageListEl.innerHTML = `<div class="page-list-empty">Drop PDFs to build a playlist of sheets. Drag entries to reorder, rotate them, and view the page in the native viewer.</div>`;
        counterEl.textContent = 'No pages loaded';
        return;
      }
      counterEl.textContent = `${pages.length} page${pages.length > 1 ? 's' : ''} ready`;
      const createCard = viewStrategies[currentView] || viewStrategies.list;
      pages.forEach((page, index) => {
        const doc = documents.get(page.docId);
        const preview = pagePreviews.get(page.id);
        const card = createCard(page, index, doc, preview);
        hookCardEvents(card, page.id);
        pageListEl.appendChild(card);
      });
      runPendingPreviewFlips();
    }

    function buildPreviewMarkup(page, index, preview) {
      const content = preview
        ? `<img src="${preview}" alt="Page preview ${index + 1}" />`
        : '<div class="preview-placeholder">Rendering...</div>';
      return `
          <div class="preview-face" data-preview="${page.id}">
            <div class="preview-plane" style="transform: rotate(${page.rotation}deg);">
              ${content}
            </div>
          </div>
        `;
    }

    function createListCard(page, index, doc, preview) {
      const card = document.createElement('div');
      card.className = 'page-card';
      card.draggable = true;
      card.dataset.pageId = page.id;
      card.innerHTML = `
          <div class="page-card__meta">
            <div class="page-card__details">
              <div class="page-preview">
                ${buildPreviewMarkup(page, index, preview)}
              </div>
              <div>
                <p class="chip">Page ${index + 1}</p>
                <p class="title">${doc.name}</p>
                <p class="subtext">Original page ${page.pageIndex + 1}</p>
              </div>
            </div>
            <div class="subtext">Rotation: ${page.rotation}&deg;</div>
          </div>
          <div class="page-card__actions">
            <button data-action="rotate" class="btn text rotate">Rotate +90&deg;</button>
            <button data-action="remove" class="btn text danger">Remove</button>
            <a class="btn text dark" target="_blank" rel="noopener" href="${doc.url}#page=${page.pageIndex + 1}">View source</a>
          </div>
        `;
      return card;
    }

    function createTileCard(page, index, doc, preview) {
      const card = document.createElement('div');
      card.className = 'tile-card';
      card.draggable = true;
      card.dataset.pageId = page.id;
      card.innerHTML = `
          <div class="tile-thumb">
            ${buildPreviewMarkup(page, index, preview)}
          </div>
          <div class="tile-meta">
            <p class="tile-name">${doc.name}</p>
            <p class="tile-sub">#${index + 1} · Original page ${page.pageIndex + 1}</p>
          </div>
          <div class="tile-actions">
            <button data-action="rotate" class="icon rotate" title="Rotate +90°">⟳</button>
            <button data-action="remove" class="icon remove" title="Remove page">✕</button>
            <a class="icon" target="_blank" rel="noopener" href="${doc.url}#page=${page.pageIndex + 1}" title="Open source">↗</a>
          </div>
        `;
      return card;
    }

    function hookCardEvents(card, pageId) {
      card.addEventListener('dragstart', (event) => {
        dragSourceId = pageId;
        event.dataTransfer.effectAllowed = 'move';
        card.classList.add('dragging');
      });
      card.addEventListener('dragend', () => {
        dragSourceId = null;
        card.classList.remove('dragging');
      });
      card.addEventListener('dragover', (event) => {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
      });
      card.addEventListener('drop', (event) => {
        event.preventDefault();
        const targetId = pageId;
        if (!dragSourceId || dragSourceId === targetId) return;
        const bounds = card.getBoundingClientRect();
        const before = event.clientY < bounds.top + bounds.height / 2;
        movePage(dragSourceId, targetId, before ? 'before' : 'after');
      });
      card.addEventListener('click', (event) => {
        const action = event.target.dataset.action;
        if (!action) return;
        if (action === 'rotate') {
          const page = pages.find((p) => p.id === pageId);
          page.rotation = (page.rotation + 90) % 360;
          queuePreviewFlip(pageId);
          renderPages();
        }
        if (action === 'remove') {
          pages = pages.filter((p) => p.id !== pageId);
          pagePreviews.delete(pageId);
          pendingFlipIds.delete(pageId);
          renderPages();
        }
      });
    }

    function movePage(sourceId, targetId, position) {
      const srcIndex = pages.findIndex((p) => p.id === sourceId);
      if (srcIndex === -1) return;
      const [entry] = pages.splice(srcIndex, 1);
      let targetIndex = pages.findIndex((p) => p.id === targetId);
      if (targetIndex === -1) {
        pages.splice(srcIndex, 0, entry);
        return;
      }
      if (position === 'after') {
        targetIndex += 1;
      }
      pages.splice(targetIndex, 0, entry);
      renderPages();
    }

    function ingestFiles(fileList) {
      statusEl.textContent = 'Loading files...';
      const jobs = Array.from(fileList).map((file) => loadPdf(file));
      Promise.all(jobs)
        .then(() => {
          statusEl.textContent = 'Files imported successfully.';
          renderPages();
        })
        .catch((error) => {
          console.error(error);
          statusEl.textContent = 'Some files could not be processed. Make sure they are valid PDFs.';
          renderPages();
        });
    }

    async function loadPdf(file) {
      const buffer = await file.arrayBuffer();
      const pdfLibBuffer = buffer.slice(0);
      const previewBuffer = buffer.slice(0);
      const byteArray = new Uint8Array(previewBuffer);
      const docId = `${file.name}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      const pdfDoc = await PDFDocument.load(pdfLibBuffer);
      const previewDoc = await pdfjsLib.getDocument({ data: byteArray }).promise;
      const pageCount = pdfDoc.getPageCount();
      const url = URL.createObjectURL(new Blob([buffer], { type: 'application/pdf' }));
      documents.set(docId, { name: file.name, bytes: pdfLibBuffer, url, pageCount });
      for (let i = 0; i < pageCount; i += 1) {
        const thumbnail = await renderThumbnail(previewDoc, i);
        const pageEntry = {
          id: `${docId}-p${i}`,
          docId,
          pageIndex: i,
          rotation: 0,
        };
        pages.push(pageEntry);
        pagePreviews.set(pageEntry.id, thumbnail);
      }
    }

    async function renderThumbnail(pdfDoc, pageIndex) {
      const page = await pdfDoc.getPage(pageIndex + 1);
      const baseViewport = page.getViewport({ scale: 1 });
      const targetWidth = 120;
      const scale = targetWidth / baseViewport.width;
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      await page.render({ canvasContext: context, viewport }).promise;
      return canvas.toDataURL('image/png');
    }
  </script>
</body>

</html>