<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.tailwindcss.com"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metal Bending Editor v5 (Flat Pattern & PDF)</title>
    <!-- Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <!-- PDF Lib -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        bg: '#121212',
                        surface: '#1e1e1e',
                        border: '#333333',
                        primary: '#3b82f6', // blue-500
                        accent: '#eab308', // yellow-500
                        text: '#e5e7eb',
                        muted: '#9ca3af'
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');
        
        body { font-family: 'Inter', sans-serif; background-color: #121212; color: #e5e7eb; }
        
        /* Custom UI Elements */
        .glass-panel {
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-input {
            background: #2a2a2a;
            border: 1px solid #404040;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            width: 100%;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .control-input:focus {
            border-color: #3b82f6;
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .segment-item {
            transition: background 0.2s;
            cursor: pointer;
        }
        .segment-item:hover { background: #2a2a2a; }
        .segment-item.active { 
            background: #252a35; 
            border-left: 3px solid #3b82f6;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col md:flex-row">

    <!-- LEFT SIDEBAR: CONTROLS -->
    <div class="w-full md:w-[380px] h-full flex flex-col border-r border-border bg-surface z-20 shadow-2xl flex-shrink-0">
        
        <!-- Header -->
        <div class="p-5 border-b border-border bg-[#181818]">
            <h1 class="text-lg font-semibold flex items-center gap-2 text-white">
                <i class="fa-solid fa-shapes text-primary"></i>
                Bending Studio <span class="text-[10px] bg-primary/20 text-primary px-1.5 py-0.5 rounded uppercase font-bold">v0.0.5</span>
            </h1>
            <p class="text-xs text-muted mt-1">Interactive Profile Editor</p>
        </div>

        <!-- Global Settings -->
        <div class="p-4 grid grid-cols-3 gap-3 border-b border-border bg-[#1a1a1a]">
            <div>
                <label class="text-[10px] text-muted uppercase font-bold">Thickness (T)</label>
                <input type="number" id="thickness" value="2.0" step="0.1" class="control-input mt-1">
            </div>
            <div>
                <label class="text-[10px] text-muted uppercase font-bold">Radius (R)</label>
                <input type="number" id="radius" value="2.0" step="0.1" class="control-input mt-1">
            </div>
            <div>
                <label class="text-[10px] text-muted uppercase font-bold">K-Factor</label>
                <input type="number" id="k-factor" value="0.44" step="0.01" class="control-input mt-1">
            </div>
        </div>

        <!-- Segments List -->
        <div class="flex-1 overflow-y-auto flex flex-col relative">
            <div class="sticky top-0 bg-surface z-10 p-3 border-b border-border flex justify-between items-center">
                <span class="text-xs font-semibold text-white uppercase tracking-wider">Operations (Segments)</span>
                <span id="bend-count-badge" class="text-[10px] bg-gray-700 px-2 py-0.5 rounded-full text-white">0 Bends</span>
            </div>
            
            <div id="segments-list" class="flex-1 p-2 space-y-1">
                <!-- Segments injected here -->
            </div>

            <!-- Empty State -->
            <div id="empty-state" class="hidden h-full flex flex-col items-center justify-center text-muted p-8 text-center opacity-50">
                <i class="fa-solid fa-arrow-pointer text-2xl mb-2"></i>
                <p class="text-sm">Click "Add Segment" to start</p>
            </div>
        </div>

        <!-- Active Segment Editor -->
        <div id="active-editor" class="p-4 bg-[#232323] border-t border-border hidden">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-xs font-bold text-primary uppercase">Edit Segment #<span id="active-id">1</span></h3>
                <button onclick="deleteActiveSegment()" class="text-red-400 hover:text-red-300 text-xs transition">
                    <i class="fa-solid fa-trash"></i> Delete
                </button>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="text-[10px] text-muted block mb-1">Length (mm)</label>
                    <div class="relative">
                        <input type="number" id="edit-length" class="control-input pl-7" oninput="updateActiveSegment()">
                        <span class="absolute left-2 top-1.5 text-gray-500 text-xs"><i class="fa-solid fa-ruler"></i></span>
                    </div>
                </div>
                <div>
                    <label class="text-[10px] text-muted block mb-1">Angle (deg)</label>
                    <div class="relative">
                        <input type="number" id="edit-angle" class="control-input pl-7" oninput="updateActiveSegment()">
                        <span class="absolute left-2 top-1.5 text-gray-500 text-xs"><i class="fa-solid fa-rotate"></i></span>
                    </div>
                </div>
            </div>
            <p class="text-[10px] text-gray-500 mt-2 italic">* 0 = Straight. 90 = Up.</p>
        </div>

        <!-- Actions -->
        <div class="p-4 border-t border-border bg-surface flex flex-col gap-2">
            <button onclick="addSegment()" class="w-full py-2 bg-[#2a2a2a] hover:bg-[#333] border border-[#444] text-white text-sm rounded transition flex items-center justify-center gap-2">
                <i class="fa-solid fa-plus text-primary"></i> Add Segment
            </button>
            <div class="grid grid-cols-2 gap-2 mt-1">
                 <button id="dxf-btn" class="py-2 bg-primary hover:bg-blue-600 text-white text-sm font-medium rounded shadow transition flex items-center justify-center gap-2">
                    <i class="fa-solid fa-file-export"></i> DXF
                </button>
                <button id="pdf-btn" class="py-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-medium rounded shadow transition flex items-center justify-center gap-2">
                    <i class="fa-solid fa-file-pdf"></i> Report PDF
                </button>
            </div>
        </div>
    </div>

    <!-- RIGHT MAIN: WORKSPACE -->
    <div class="flex-1 relative bg-[#0f0f10] flex flex-col h-full overflow-hidden">
        
        <!-- TOP: 2D PROFILE CANVAS -->
        <div class="flex-1 relative border-b border-border flex flex-col min-h-0">
            <!-- Toolbar -->
            <div class="absolute top-4 left-4 z-10 glass-panel rounded-lg p-1.5 flex gap-1 shadow-lg">
                <div class="flex bg-[#2a2a2a] rounded p-0.5">
                    <button onclick="setDimMode('segment')" id="btn-mode-segment" class="px-3 py-1.5 text-[10px] font-bold rounded text-white bg-primary transition" title="Segment Lengths">
                        <i class="fa-solid fa-ruler-horizontal mr-1"></i> Segments
                    </button>
                    <button onclick="setDimMode('chain')" id="btn-mode-chain" class="px-3 py-1.5 text-[10px] font-bold rounded text-gray-400 hover:text-white transition" title="Cumulative Length">
                        <i class="fa-solid fa-link mr-1"></i> Chain
                    </button>
                    <button onclick="setDimMode('bounds')" id="btn-mode-bounds" class="px-3 py-1.5 text-[10px] font-bold rounded text-gray-400 hover:text-white transition" title="Overall Bounds">
                        <i class="fa-solid fa-maximize mr-1"></i> Bounds
                    </button>
                </div>
            </div>

            <!-- Stats Overlay -->
            <div class="absolute bottom-6 left-6 z-10 pointer-events-none">
                <div class="glass-panel p-4 rounded-xl shadow-2xl border-l-4 border-accent">
                    <div class="text-[10px] text-gray-400 uppercase tracking-wide">Cut Length</div>
                    <div id="total-length-display" class="text-2xl font-mono font-bold text-white mt-0.5">0.00 <span class="text-sm text-gray-500">mm</span></div>
                </div>
            </div>

            <div id="canvas-wrapper" class="w-full h-full relative cursor-crosshair bg-[#0f0f10]">
                 <div class="absolute inset-0 opacity-10 pointer-events-none" 
                     style="background-image: linear-gradient(#444 1px, transparent 1px), linear-gradient(90deg, #444 1px, transparent 1px); background-size: 50px 50px;">
                </div>
                <canvas id="main-canvas"></canvas>
            </div>
        </div>

        <!-- BOTTOM: FLAT PATTERN PREVIEW (Resizable/Fixed Height) -->
        <div class="h-[250px] bg-[#141414] flex flex-col border-t border-border flex-shrink-0">
            <!-- Header/Controls -->
            <div class="h-10 border-b border-border bg-[#1a1a1a] flex items-center justify-between px-4">
                <span class="text-xs font-bold text-gray-400 uppercase flex items-center gap-2">
                    <i class="fa-solid fa-map"></i> Flat Pattern Preview
                </span>
                
                <div class="flex items-center gap-4">
                     <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" id="show-bend-info" checked class="accent-primary" onchange="renderFlatPattern()">
                        <span class="text-[10px] text-gray-400">Bend Info</span>
                    </label>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" id="show-lines-dist" checked class="accent-primary" onchange="renderFlatPattern()">
                        <span class="text-[10px] text-gray-400">Distances</span>
                    </label>
                </div>
            </div>
            
            <!-- Flat Canvas -->
            <div id="flat-wrapper" class="flex-1 relative overflow-hidden bg-[#121212]">
                <canvas id="flat-canvas"></canvas>
            </div>
        </div>

    </div>

    <script>
        // --- STATE MANAGEMENT ---
        let segments = [
            { id: 1, length: 50, angle: 0 },   // Start straight
            { id: 2, length: 50, angle: 90 },  // Bend up
            { id: 3, length: 30, angle: -90 }, // Bend down
        ];
        
        let appState = {
            activeSegmentId: null,
            dimMode: 'chain', // 'segment', 'chain', 'bounds'
            totalFlatLength: 0,
            scale: 1.5,
            pan: { x: 0, y: 0 },
            isDragging: false,
            lastMouse: { x: 0, y: 0 },
            flatScale: 1
        };

        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvas-wrapper');

        const flatCanvas = document.getElementById('flat-canvas');
        const flatCtx = flatCanvas.getContext('2d');
        const flatWrapper = document.getElementById('flat-wrapper');
        
        // --- INIT ---

        function init() {
            resizeCanvases();
            renderUI();
            recalculate();
            
            // Render Loop
            requestAnimationFrame(drawLoop);
            
            // Events
            window.addEventListener('resize', () => { resizeCanvases(); renderFlatPattern(); });
            wrapper.addEventListener('mousedown', onMouseDown);
            wrapper.addEventListener('mousemove', onMouseMove);
            wrapper.addEventListener('mouseup', onMouseUp);
            wrapper.addEventListener('wheel', onWheel);
            
            // Select first
            if(segments.length > 0) selectSegment(segments[0].id);

            // Inputs
            ['thickness', 'radius', 'k-factor'].forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    recalculate();
                    renderUI();
                });
            });
            
            document.getElementById('dxf-btn').addEventListener('click', generateDXF);
            document.getElementById('pdf-btn').addEventListener('click', generatePDF);
        }

        // --- CORE CALCULATIONS ---

        function recalculate() {
            const T = parseFloat(document.getElementById('thickness').value) || 0;
            const R = parseFloat(document.getElementById('radius').value) || 0;
            const K = parseFloat(document.getElementById('k-factor').value) || 0;
            
            let totalLen = 0;
            let bendCount = 0;
            let currentCumulative = 0;
            
            // Reset computed data
            segments.forEach(s => { s._computed = {}; });

            let setbacks = []; // Outer Setbacks
            
            // 1. Calculate setbacks
            for(let i = 0; i < segments.length; i++) {
                if (i < segments.length - 1) {
                    const nextSeg = segments[i+1];
                    const angle = nextSeg.angle; 
                    const rad = Math.abs(angle * Math.PI / 180);
                    // Setback = (R + T) * tan(angle/2)
                    const sb = (R + T) * Math.tan(rad/2);
                    setbacks.push({ sb, rad, angle });
                    bendCount++;
                } else {
                    setbacks.push({ sb: 0, rad: 0, angle: 0 });
                }
            }

            // 2. Calculate Flat Lengths
            for(let i = 0; i < segments.length; i++) {
                const prevSB = (i === 0) ? 0 : setbacks[i-1].sb;
                const nextSB = setbacks[i].sb;
                
                // Straight length
                let straight = segments[i].length - prevSB - nextSB;
                if(straight < 0) straight = 0; 
                
                // Bend Allowance
                let ba = 0;
                let bendDir = 0; // 1 = up, -1 = down
                let bendAngle = 0;
                
                if(i > 0) {
                     const prevCorner = setbacks[i-1];
                     // BA = AngleRad * (R + K*T)
                     ba = prevCorner.rad * (R + (K * T));
                     bendDir = prevCorner.angle > 0 ? 1 : -1;
                     bendAngle = prevCorner.angle;
                }

                // Store computed data for this segment (and the bend preceeding it)
                segments[i]._computed = {
                    straightLen: straight,
                    prevBA: ba,
                    startDist: currentCumulative, // Start of STRAIGHT part
                    bendCenterDist: currentCumulative - (ba/2), // Center of the previous bend
                    bendAngle: bendAngle,
                    bendDir: bendDir
                };
                
                totalLen += straight + ba;
                currentCumulative += ba + straight;
            }

            appState.totalFlatLength = totalLen;
            
            // Update UI
            document.getElementById('total-length-display').innerHTML = `${totalLen.toFixed(2)} <span class="text-sm text-gray-500">mm</span>`;
            document.getElementById('bend-count-badge').innerText = `${bendCount} Bends`;

            renderFlatPattern();
        }

        // --- PROFILE DRAWING ENGINE (TOP CANVAS) ---

        function drawLoop() {
            // Background
            ctx.fillStyle = '#0f0f10';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(canvas.width/2 + appState.pan.x, canvas.height/2 + appState.pan.y);
            ctx.scale(appState.scale, appState.scale);

            drawOrigin();
            drawProfile();

            ctx.restore();
            requestAnimationFrame(drawLoop);
        }

        function drawOrigin() {
            ctx.lineWidth = 2 / appState.scale;
            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(-20, 0); ctx.lineTo(20, 0);
            ctx.moveTo(0, -20); ctx.lineTo(0, 20);
            ctx.stroke();
            
            ctx.fillStyle = '#eab308';
            ctx.beginPath(); ctx.arc(0,0, 3/appState.scale, 0, Math.PI*2); ctx.fill();
        }

        function drawProfile() {
            const T = parseFloat(document.getElementById('thickness').value) || 2;
            const R = parseFloat(document.getElementById('radius').value) || 2;
            const Rc = R + T/2; 

            let curX = 0, curY = 0, curAng = 0;
            let bounds = { minX:0, maxX:0, minY:0, maxY:0 };
            
            const updateBounds = (x,y) => {
                bounds.minX = Math.min(bounds.minX, x);
                bounds.maxX = Math.max(bounds.maxX, x);
                bounds.minY = Math.min(bounds.minY, y);
                bounds.maxY = Math.max(bounds.maxY, y);
            };

            let pathNodes = []; 

            segments.forEach((seg, i) => {
                const comp = seg._computed;
                const straight = comp.straightLen;
                const isSelected = (seg.id === appState.activeSegmentId);

                // 1. Draw Previous Bend (Arc)
                if (i > 0) {
                    const turnAngle = seg.angle; 
                    const rad = turnAngle * Math.PI / 180;
                    const sign = (turnAngle >= 0) ? 1 : -1; 
                    const centerAng = curAng + (Math.PI/2 * sign);
                    const cx = curX + Rc * Math.cos(centerAng);
                    const cy = curY + Rc * Math.sin(centerAng);
                    const startAng = centerAng + Math.PI; 
                    const endAng = startAng + rad;

                    ctx.beginPath();
                    ctx.arc(cx, cy, Rc, startAng, endAng, (turnAngle < 0));
                    ctx.lineWidth = T;
                    ctx.strokeStyle = '#ffffff'; 
                    ctx.stroke();

                    curX = cx + Rc * Math.cos(endAng);
                    curY = cy + Rc * Math.sin(endAng);
                    curAng += rad;
                }

                // 2. Draw Straight Section
                const dx = straight * Math.cos(curAng);
                const dy = straight * Math.sin(curAng);
                const nextX = curX + dx;
                const nextY = curY + dy;

                ctx.beginPath();
                ctx.moveTo(curX, curY);
                ctx.lineTo(nextX, nextY);
                ctx.lineWidth = T;
                ctx.strokeStyle = isSelected ? '#3b82f6' : '#555'; 
                ctx.lineCap = 'butt';
                ctx.stroke();
                
                if(isSelected) {
                    ctx.shadowColor = '#3b82f6';
                    ctx.shadowBlur = 10;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                pathNodes.push({
                    id: seg.id,
                    x1: curX, y1: curY, x2: nextX, y2: nextY,
                    angle: curAng,
                    mx: (curX+nextX)/2, my: (curY+nextY)/2
                });

                // DIMENSIONS
                const dimScale = 1/appState.scale;
                ctx.font = `${12 * dimScale}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const nx = -Math.sin(curAng);
                const ny = Math.cos(curAng);
                const textOffset = (T/2 + 10) * dimScale;

                if (appState.dimMode === 'segment' && straight > 1) {
                    ctx.fillStyle = isSelected ? '#3b82f6' : '#ccc';
                    ctx.fillText(straight.toFixed(1), (curX + nextX)/2 + nx*textOffset, (curY + nextY)/2 + ny*textOffset);
                }

                if (appState.dimMode === 'chain' && i < segments.length) {
                     // Draw cumulative to Start of next bend (End of straight)
                    const dist = comp.startDist + straight;
                    const markerLen = 15 * dimScale;
                    ctx.beginPath();
                    ctx.moveTo(nextX, nextY);
                    ctx.lineTo(nextX + nx*markerLen*1.5, nextY + ny*markerLen*1.5);
                    ctx.lineWidth = 1 * dimScale;
                    ctx.strokeStyle = '#eab308';
                    ctx.stroke();

                    ctx.fillStyle = '#eab308';
                    ctx.fillText(`L=${dist.toFixed(1)}`, nextX + nx*markerLen*2.5, nextY + ny*markerLen*2.5);
                }

                updateBounds(curX, curY);
                updateBounds(nextX, nextY);

                curX = nextX;
                curY = nextY;
            });

            if (appState.dimMode === 'bounds') {
                ctx.lineWidth = 1 / appState.scale;
                ctx.strokeStyle = '#666';
                ctx.setLineDash([5/appState.scale, 5/appState.scale]);
                ctx.strokeRect(bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                ctx.setLineDash([]);
                ctx.fillStyle = '#fff';
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                ctx.fillText(`X: ${width.toFixed(1)}`, (bounds.minX+bounds.maxX)/2, bounds.maxY + 20/appState.scale);
                ctx.fillText(`Y: ${height.toFixed(1)}`, bounds.maxX + 20/appState.scale, (bounds.minY+bounds.maxY)/2);
            }

            appState.pathNodes = pathNodes;
        }

        // --- FLAT PATTERN RENDERER (BOTTOM CANVAS) ---

        function renderFlatPattern() {
            const width = flatCanvas.width;
            const height = flatCanvas.height;
            const L = appState.totalFlatLength;
            if(L <= 0) return;

            // Clear
            flatCtx.fillStyle = '#141414';
            flatCtx.fillRect(0, 0, width, height);

            // Auto Scale
            const margin = 40;
            const partHeight = 60; // Visual height of the strip
            const scaleX = (width - margin*2) / L;
            const scaleY = 1; // Not really scaling Y geometrically, just fixed height strip
            const scale = Math.min(scaleX, 5); // Max scale limit
            
            const startX = (width - (L * scale)) / 2;
            const centerY = height / 2;

            // 1. Draw Plate
            flatCtx.fillStyle = '#2a2a2a';
            flatCtx.strokeStyle = '#555';
            flatCtx.lineWidth = 2;
            flatCtx.fillRect(startX, centerY - partHeight/2, L*scale, partHeight);
            flatCtx.strokeRect(startX, centerY - partHeight/2, L*scale, partHeight);

            const showInfo = document.getElementById('show-bend-info').checked;
            const showDist = document.getElementById('show-lines-dist').checked;

            // 2. Draw Bends
            segments.forEach((seg, i) => {
                const comp = seg._computed;
                
                // If this segment was preceded by a bend (i > 0)
                if (i > 0 && comp.prevBA > 0) {
                    const centerX = startX + (comp.bendCenterDist * scale);
                    const baWidth = comp.prevBA * scale;
                    const lineLeft = centerX - baWidth/2;
                    const lineRight = centerX + baWidth/2;
                    
                    // Draw Bend Area
                    flatCtx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                    flatCtx.fillRect(lineLeft, centerY - partHeight/2, baWidth, partHeight);

                    // Center Line (Dashed)
                    flatCtx.beginPath();
                    flatCtx.moveTo(centerX, centerY - partHeight/2 - 5);
                    flatCtx.lineTo(centerX, centerY + partHeight/2 + 5);
                    flatCtx.strokeStyle = comp.bendDir > 0 ? '#4ade80' : '#facc15'; // Green (Up) or Yellow (Down)
                    flatCtx.setLineDash([5, 3]);
                    flatCtx.lineWidth = 1;
                    flatCtx.stroke();
                    flatCtx.setLineDash([]);

                    // Bend Info Text
                    if (showInfo) {
                        flatCtx.font = '10px Inter';
                        flatCtx.fillStyle = '#ccc';
                        flatCtx.textAlign = 'center';
                        const dirStr = comp.bendDir > 0 ? "UP" : "DOWN";
                        const info = `${Math.abs(comp.bendAngle)}° ${dirStr} R${document.getElementById('radius').value}`;
                        flatCtx.fillText(info, centerX, centerY - partHeight/2 - 15);
                    }

                    // Distance Text
                    if (showDist) {
                         flatCtx.font = 'bold 11px JetBrains Mono';
                         flatCtx.fillStyle = '#eab308';
                         flatCtx.textAlign = 'center';
                         flatCtx.fillText(comp.bendCenterDist.toFixed(1), centerX, centerY + partHeight/2 + 20);
                    }
                }
            });
            
            // Draw Zero Marker
            if (showDist) {
                flatCtx.fillStyle = '#eab308';
                flatCtx.fillText("0.0", startX, centerY + partHeight/2 + 20);
                flatCtx.beginPath();
                flatCtx.moveTo(startX, centerY + partHeight/2);
                flatCtx.lineTo(startX, centerY + partHeight/2 + 8);
                flatCtx.strokeStyle = '#eab308';
                flatCtx.lineWidth = 1;
                flatCtx.stroke();
            }
        }

        // --- INTERACTION ---

        function setDimMode(mode) {
            appState.dimMode = mode;
            ['segment', 'chain', 'bounds'].forEach(m => {
                const btn = document.getElementById(`btn-mode-${m}`);
                if(m === mode) {
                    btn.classList.remove('bg-transparent', 'text-gray-400');
                    btn.classList.add('bg-primary', 'text-white');
                } else {
                    btn.classList.add('bg-transparent', 'text-gray-400');
                    btn.classList.remove('bg-primary', 'text-white');
                }
            });
        }

        function onMouseDown(e) {
            appState.isDragging = true;
            appState.lastMouse = { x: e.clientX, y: e.clientY };
            
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left - canvas.width/2 - appState.pan.x) / appState.scale;
            const my = (e.clientY - rect.top - canvas.height/2 - appState.pan.y) / appState.scale;

            let hitId = null;
            if (appState.pathNodes) {
                const hitDist = 10 / appState.scale; 
                for(let node of appState.pathNodes) {
                    const d = distToSegment({x:mx, y:my}, {x:node.x1, y:node.y1}, {x:node.x2, y:node.y2});
                    if (d < hitDist) { hitId = node.id; break; }
                }
            }
            if(hitId) {
                selectSegment(hitId);
                appState.isDragging = false; 
            }
        }

        function onMouseMove(e) {
            if (appState.isDragging) {
                const dx = e.clientX - appState.lastMouse.x;
                const dy = e.clientY - appState.lastMouse.y;
                appState.pan.x += dx;
                appState.pan.y += dy;
                appState.lastMouse = { x: e.clientX, y: e.clientY };
            }
        }

        function onMouseUp() { appState.isDragging = false; }

        function onWheel(e) {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const dir = e.deltaY > 0 ? -1 : 1;
            const factor = 1 + (dir * zoomSpeed);
            appState.scale *= factor;
            if(appState.scale < 0.1) appState.scale = 0.1;
            if(appState.scale > 20) appState.scale = 20;
        }
        
        function distToSegment(p, v, w) {
            const l2 = (w.x - v.x)**2 + (w.y - v.y)**2;
            if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
        }

        // --- UI MANAGEMENT ---

        function renderUI() {
            const list = document.getElementById('segments-list');
            list.innerHTML = '';
            
            if(segments.length === 0) {
                document.getElementById('empty-state').classList.remove('hidden');
                document.getElementById('active-editor').classList.add('hidden');
                return;
            } else {
                document.getElementById('empty-state').classList.add('hidden');
                document.getElementById('active-editor').classList.remove('hidden');
            }

            segments.forEach((seg, index) => {
                const isActive = seg.id === appState.activeSegmentId;
                const el = document.createElement('div');
                el.className = `segment-item p-3 rounded border border-transparent ${isActive ? 'active border-l-blue-500 bg-[#252a35]' : 'border-gray-800'}`;
                el.onclick = () => selectSegment(seg.id);
                
                let icon = 'fa-minus';
                let type = 'Straight';
                if(seg.angle > 0) { icon = 'fa-arrow-turn-up'; type = 'Up'; }
                if(seg.angle < 0) { icon = 'fa-arrow-turn-down'; type = 'Down'; }
                if(index === 0) { icon = 'fa-play'; type = 'Start'; }

                el.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="flex items-center gap-3">
                            <div class="w-6 h-6 rounded bg-[#333] flex items-center justify-center text-[10px] text-gray-400">
                                <i class="fa-solid ${icon}"></i>
                            </div>
                            <div>
                                <div class="text-xs font-bold text-white">Segment #${index + 1}</div>
                                <div class="text-[10px] text-gray-500">${type} ${index > 0 ? Math.abs(seg.angle)+'°' : ''}</div>
                            </div>
                        </div>
                        <div class="text-right">
                            <div class="text-sm font-mono text-primary">${seg.length} <span class="text-[10px] text-gray-600">mm</span></div>
                        </div>
                    </div>
                `;
                list.appendChild(el);
            });
        }

        function addSegment() {
            const newId = Date.now();
            segments.push({ id: newId, length: 50, angle: segments.length === 0 ? 0 : 90 });
            recalculate();
            selectSegment(newId);
        }

        function selectSegment(id) {
            appState.activeSegmentId = id;
            renderUI();
            const seg = segments.find(s => s.id === id);
            if(seg) {
                document.getElementById('active-id').innerText = segments.indexOf(seg) + 1;
                document.getElementById('edit-length').value = seg.length;
                document.getElementById('edit-angle').value = seg.angle;
                document.getElementById('edit-angle').disabled = (segments.indexOf(seg) === 0);
            }
        }

        function updateActiveSegment() {
            const id = appState.activeSegmentId;
            const seg = segments.find(s => s.id === id);
            if(seg) {
                const l = parseFloat(document.getElementById('edit-length').value);
                const a = parseFloat(document.getElementById('edit-angle').value);
                if(!isNaN(l)) seg.length = l;
                if(!isNaN(a)) seg.angle = a;
                recalculate();
                renderUI(); 
            }
        }

        function deleteActiveSegment() {
            segments = segments.filter(s => s.id !== appState.activeSegmentId);
            if(segments.length > 0) selectSegment(segments[segments.length-1].id);
            else { appState.activeSegmentId = null; renderUI(); }
            recalculate();
        }

        function resizeCanvases() {
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            flatCanvas.width = flatWrapper.clientWidth;
            flatCanvas.height = flatWrapper.clientHeight;
            appState.pan.x = 0; appState.pan.y = 0;
            renderFlatPattern();
        }

        // --- DXF EXPORT ---
        function generateDXF() {
             let d = `  0\nSECTION\n  2\nHEADER\n  9\n$ACADVER\n  1\nAC1009\n  0\nENDSEC\n  0\nSECTION\n  2\nENTITIES\n`;
             const L = appState.totalFlatLength;
             const W = 100; 
             d += lineDXF(0,0, L,0); d += lineDXF(L,0, L,W); d += lineDXF(L,W, 0,W); d += lineDXF(0,W, 0,0);
             segments.forEach((seg, i) => {
                 if (i > 0 && seg._computed.prevBA > 0) {
                     const center = seg._computed.bendCenterDist;
                     d += lineDXF(center, 0, center, W, 3); 
                 }
             });
             d += `  0\nENDSEC\n  0\nEOF\n`;
             download(d, 'part.dxf');
        }

        function lineDXF(x1,y1,x2,y2, color=7) {
            return `  0\nLINE\n  8\n0\n 62\n${color}\n 10\n${x1}\n 20\n${y1}\n 30\n0\n 11\n${x2}\n 21\n${y2}\n 31\n0\n`;
        }

        function download(content, name) {
            const blob = new Blob([content], {type: 'text/plain'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = name; a.click();
        }

        // --- PDF EXPORT (FULL REPORT) ---
        function generatePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // 1. Header
            doc.setFontSize(18);
            doc.text("Bending Report", 14, 20);
            
            doc.setFontSize(10);
            doc.setTextColor(100);
            doc.text(`Generated: ${new Date().toLocaleDateString()}`, 14, 26);
            
            // 2. Parameters
            const T = document.getElementById('thickness').value;
            const R = document.getElementById('radius').value;
            const K = document.getElementById('k-factor').value;
            const L = appState.totalFlatLength.toFixed(2);
            
            const params = [
                ['Material Thickness', `${T} mm`],
                ['Inner Radius', `${R} mm`],
                ['K-Factor', K],
                ['Total Cut Length', `${L} mm`],
                ['Total Bends', segments.length - 1]
            ];
            
            doc.autoTable({
                startY: 35,
                head: [['Parameter', 'Value']],
                body: params,
                theme: 'grid',
                headStyles: { fillColor: [59, 130, 246] }, // Blue
                styles: { fontSize: 10 }
            });

            // 3. Profile Image
            // We need to capture the canvas, but without the dark background if possible.
            // For simplicity, we just invert/capture current.
            // To make it look good, we could temporarily change background to white, redraw, capture, restore.
            const oldBg = '#0f0f10';
            const oldStroke = '#ffffff';
            
            // Capture Profile
            const imgData = canvas.toDataURL("image/png");
            // Add to PDF
            let finalY = doc.lastAutoTable.finalY + 10;
            doc.setFontSize(12);
            doc.setTextColor(0);
            doc.text("Profile View", 14, finalY);
            // Fit image
            const imgProps = doc.getImageProperties(imgData);
            const pdfWidth = doc.internal.pageSize.getWidth() - 28;
            const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
            doc.addImage(imgData, 'PNG', 14, finalY + 5, pdfWidth, pdfHeight);
            
            // 4. Flat Pattern Image
            const flatImg = flatCanvas.toDataURL("image/png");
            finalY += pdfHeight + 20;
            
            // Check page break
            if (finalY > 250) { doc.addPage(); finalY = 20; }
            
            doc.text("Flat Pattern View", 14, finalY);
            const flatProps = doc.getImageProperties(flatImg);
            const flatPdfHeight = (flatProps.height * pdfWidth) / flatProps.width;
            doc.addImage(flatImg, 'PNG', 14, finalY + 5, pdfWidth, flatPdfHeight);
            
            // 5. Bend Table
            finalY += flatPdfHeight + 20;
             if (finalY > 250) { doc.addPage(); finalY = 20; }
            
            doc.text("Bend Sequence", 14, finalY);
            
            let bendData = [];
            segments.forEach((seg, i) => {
                if(i > 0 && seg._computed.prevBA > 0) {
                    const comp = seg._computed;
                    bendData.push([
                        i,
                        comp.bendCenterDist.toFixed(2) + ' mm',
                        Math.abs(comp.bendAngle) + '°',
                        comp.bendDir > 0 ? 'UP' : 'DOWN',
                        comp.prevBA.toFixed(2) + ' mm'
                    ]);
                }
            });
            
            doc.autoTable({
                startY: finalY + 5,
                head: [['#', 'Position (from 0)', 'Angle', 'Direction', 'Bend Allowance']],
                body: bendData,
                theme: 'striped',
                headStyles: { fillColor: [234, 179, 8] }, // Yellow accent
                styles: { fontSize: 10 }
            });

            doc.save("bending_report.pdf");
        }

        // Start
        init();

    </script>
</body>
</html>