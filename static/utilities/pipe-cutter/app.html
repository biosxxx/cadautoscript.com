<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipe Notch Template Generator</title>

    <!-- Tailwind CSS -->
    <script src="../../vendor/tailwindcss.js"></script>

    <!-- Three.js & OrbitControls -->
    <script src="../../vendor/three.min.js"></script>
    <script src="../../vendor/OrbitControls.script.js"></script>

    <!-- Google Fonts (Removed) -->
    <!-- <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet"> -->

    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #121212;
            color: #e2e2e2;
            overflow: hidden;
        }

        /* MD3 Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Inputs */
        .md-input-group {
            position: relative;
            margin-bottom: 1.5rem;
        }

        .md-input {
            width: 100%;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 1rem;
            outline: none;
            transition: all 0.2s ease;
        }

        .md-input:focus {
            border-color: #a8c7fa;
            /* MD3 Primary Light */
            background-color: #363636;
            box-shadow: 0 0 0 1px #a8c7fa;
        }

        .md-label {
            position: absolute;
            top: -10px;
            left: 12px;
            background-color: #1e1e1e;
            /* Match sidebar bg */
            padding: 0 4px;
            color: #a8c7fa;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .md-helper {
            font-size: 0.75rem;
            color: #888;
            margin-top: 4px;
            margin-left: 4px;
        }

        /* Buttons */
        .btn-primary {
            background-color: #a8c7fa;
            color: #0b1d46;
            font-weight: 600;
            border-radius: 20px;
            padding: 10px 24px;
            transition: background 0.2s;
        }

        .btn-primary:hover {
            background-color: #d8e6ff;
        }

        .btn-secondary {
            background-color: #2d2d2d;
            color: #a8c7fa;
            border: 1px solid #444;
            font-weight: 600;
            border-radius: 20px;
            padding: 10px 24px;
            transition: background 0.2s;
        }

        .btn-secondary:hover {
            background-color: #363636;
        }

        canvas {
            width: 100%;
            height: 100%;
            outline: none;
        }
    </style>
</head>

<body>

    <div class="flex flex-col md:flex-row h-screen">

        <!-- Sidebar Controls -->
        <div
            class="w-full md:w-[400px] flex-shrink-0 bg-[#1e1e1e] shadow-2xl z-10 overflow-y-auto h-screen border-r border-[#333]">
            <div class="p-6">
                <h1 class="text-2xl font-bold mb-2 text-[#e2e2e2]">Pipe Notch Generator</h1>
                <p class="text-sm text-[#aaaaaa] mb-8">
                    Calculate 2D templates and visualize intersections with precise 3D cutting geometry.
                </p>

                <!-- Input Groups -->
                <div class="space-y-1">

                    <div class="md-input-group">
                        <label class="md-label">Main Pipe Diameter (D1)</label>
                        <input type="number" id="diameter1" value="100" class="md-input">
                    </div>

                    <div class="md-input-group">
                        <label class="md-label">Notch Pipe Diameter (D2)</label>
                        <input type="number" id="diameter2" value="50" class="md-input">
                    </div>

                    <div class="md-input-group">
                        <label class="md-label">Wall Thickness (T)</label>
                        <input type="number" id="thicknessD2" value="2" class="md-input">
                        <div class="md-helper">Determines inner diameter visual.</div>
                    </div>

                    <div class="md-input-group">
                        <label class="md-label">Welding Gap</label>
                        <input type="number" id="weldingGap" value="0" class="md-input">
                    </div>

                    <div class="md-input-group">
                        <label class="md-label">Intersection Angle (°)</label>
                        <input type="number" id="intersectAngle" value="45" class="md-input">
                        <div class="md-helper">Angle between pipe axes (1-90).</div>
                    </div>

                    <div class="md-input-group">
                        <label class="md-label">Center Offset</label>
                        <input type="number" id="centerOffset" value="0" class="md-input">
                        <div class="md-helper">Offset from main pipe center.</div>
                    </div>

                    <div class="md-input-group">
                        <label class="md-label">Unwrap Start Angle (°)</label>
                        <input type="number" id="startAngle" value="0" class="md-input">
                        <div class="md-helper">Rotates the seam position.</div>
                    </div>

                    <!-- Padding Inputs hidden in a detail view or just smaller since less used -->
                    <div class="grid grid-cols-2 gap-4">
                        <div class="md-input-group">
                            <label class="md-label">Pad D2 (mm)</label>
                            <input type="number" id="paddingD2" value="20" class="md-input">
                        </div>
                        <div class="md-input-group">
                            <label class="md-label">Pad D1 (mm)</label>
                            <input type="number" id="paddingD1" value="20" class="md-input">
                        </div>
                    </div>

                </div>

                <!-- Error Box -->
                <div id="error-message"
                    class="hidden mb-6 p-4 bg-[#3c1e1e] border border-[#f2b8b5] text-[#f2b8b5] rounded-lg text-sm">
                </div>

                <!-- Actions -->
                <div class="space-y-3 mt-2 pb-8">
                    <button id="download-dxf-pipe" class="btn-primary w-full flex justify-center items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                        </svg>
                        Download D2 Template (DXF)
                    </button>
                    <button id="download-dxf-hole" class="btn-secondary w-full flex justify-center items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                        </svg>
                        Download D1 Hole (DXF)
                    </button>
                </div>
            </div>
        </div>

        <!-- 3D Viewport -->
        <div id="3d-container" class="flex-1 bg-[#0f0f0f] relative overflow-hidden">
            <!-- Canvas Injected Here -->
            <div class="absolute bottom-4 right-4 text-[#666] text-xs select-none pointer-events-none">
                Left Click: Rotate | Right Click: Pan | Scroll: Zoom
            </div>
        </div>

    </div>

    <script type="module">
        // --- Core Variables ---
        let scene, camera, renderer, controls;
        let pipe1Mesh, pipe2Mesh, seamLineMesh;

        // Materials
        const mainPipeMat = new THREE.MeshStandardMaterial({
            color: 0x444444,
            roughness: 0.4,
            metalness: 0.6
        });

        const cutPipeMat = new THREE.MeshStandardMaterial({
            color: 0x3c83f6, // Vibrant Blue
            roughness: 0.4,
            metalness: 0.3,
            side: THREE.DoubleSide
        });

        const cutSurfaceMat = new THREE.MeshBasicMaterial({
            color: 0xa8c7fa,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });

        const seamMaterial = new THREE.LineBasicMaterial({ color: 0xff5252, linewidth: 3 });

        // DOM Elements
        const inputs = {
            d1: document.getElementById('diameter1'),
            d2: document.getElementById('diameter2'),
            thick: document.getElementById('thicknessD2'),
            gap: document.getElementById('weldingGap'),
            angle: document.getElementById('intersectAngle'),
            offset: document.getElementById('centerOffset'),
            startAngle: document.getElementById('startAngle'),
            padD2: document.getElementById('paddingD2'),
            padD1: document.getElementById('paddingD1'),
            err: document.getElementById('error-message')
        };

        // --- Initialization ---
        function init() {
            init3D();

            // Event Listeners
            Object.values(inputs).forEach(el => {
                if (el.tagName === 'INPUT') el.addEventListener('input', update);
            });

            document.getElementById('download-dxf-pipe').addEventListener('click', () => downloadDXF('pipe'));
            document.getElementById('download-dxf-hole').addEventListener('click', () => downloadDXF('hole'));
            window.addEventListener('resize', onResize);

            // Initial Trigger
            update();
        }

        function init3D() {
            const container = document.getElementById('3d-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f0f); // Very dark gray

            // Fog for depth
            scene.fog = new THREE.Fog(0x0f0f0f, 200, 1000);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 2000);
            camera.position.set(150, 100, 150);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // Tone mapping for better contrast
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambient);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(50, 100, 50);
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0x445566, 0.5);
            fillLight.position.set(-50, 0, -50);
            scene.add(fillLight);

            // Grid
            const grid = new THREE.GridHelper(500, 50, 0x333333, 0x1a1a1a);
            scene.add(grid);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            const container = document.getElementById('3d-container');
            if (!container) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // --- Core Logic ---

        function update() {
            inputs.err.classList.add('hidden');

            const params = getParams();
            if (!params) return;

            const { D1, D2, angleRad, offset, gap } = params;
            const R1 = D1 / 2;
            const R2 = D2 / 2;

            // --- Rebuild Scene Objects ---
            if (pipe1Mesh) scene.remove(pipe1Mesh);
            if (pipe2Mesh) scene.remove(pipe2Mesh);
            if (seamLineMesh) scene.remove(seamLineMesh);

            // 1. Main Pipe (Vertical Y-Axis for simplicity in world space)
            const p1Geo = new THREE.CylinderGeometry(R1, R1, Math.max(D1 * 3, D2 * 4), 64, 1, true);
            pipe1Mesh = new THREE.Mesh(p1Geo, mainPipeMat);
            scene.add(pipe1Mesh);

            // 2. Notched Pipe (Pipe 2)
            const pipe2Length = D1 * 1.5 + 100; // Enough length
            const segments = 128; // High res for smooth cut
            const p2Geo = new THREE.BufferGeometry();

            const vertices = [];
            const indices = [];
            const uvs = [];

            // Math constants
            const sinTheta = Math.sin(angleRad);
            const tanTheta = Math.tan(angleRad);

            // For texture calc
            const circumference = 2 * Math.PI * R2;

            for (let y = 0; y <= 1; y++) { // 0 = cut end, 1 = far end
                for (let x = 0; x <= segments; x++) {
                    const alpha = (x / segments) * 2 * Math.PI;
                    const sinAlpha = Math.sin(alpha);
                    const cosAlpha = Math.cos(alpha);

                    // Intersection formula
                    const R1_eff = R1 + gap;

                    // Check intersection validity with safe term
                    let term = Math.pow(R1_eff, 2) - Math.pow(R2 * sinAlpha + offset, 2);

                    if (term < 0) {
                        // If term is extremely close to 0 (floating point error), clamp it
                        if (term > -0.01) {
                            term = 0;
                        } else {
                            showError("Geometry Error: Pipes do not intersect. Increase D1 or reduce Offset.");
                            return; // Stop mesh generation to avoid NANs
                        }
                    }

                    // Local coords of the circle cross section
                    const localX = R2 * cosAlpha;

                    let len = 0;

                    if (y === 0) {
                        // CUT END
                        // y_cut calculation
                        // Protect against division by zero
                        const sT = Math.abs(sinTheta) < 1e-6 ? 1e-6 : sinTheta;
                        const tT = Math.abs(tanTheta) < 1e-6 ? 1e-6 : tanTheta;

                        const part1 = (1 / sT) * Math.sqrt(term);
                        const part2 = (R2 * cosAlpha) / tT;

                        // CHANGED: Inverted sign of part2 to flip the cut side
                        const cutDepth = part1 + part2;

                        len = cutDepth;
                    } else {
                        // FAR END
                        len = (D1 + pipe2Length);
                    }

                    // Vector W (Axis of Pipe 2 directed AWAY from Pipe 1)
                    const wx = Math.sin(angleRad);
                    const wy = Math.cos(angleRad);
                    const wz = 0;

                    // Vector V (Offset direction - typically Z axis for Y-up Pipe 1)
                    const vx = 0;
                    const vy = 0;
                    const vz = 1;

                    // Vector U (Cross product V x W)
                    const ux = (vy * wz) - (vz * wy); // -cos
                    const uy = (vz * wx) - (vx * wz); // sin
                    const uz = (vx * wy) - (vy * wx); // 0

                    // Construct Vertex P
                    const pX = (R2 * cosAlpha * ux) + ((R2 * sinAlpha + offset) * vx) + (len * wx);
                    const pY = (R2 * cosAlpha * uy) + ((R2 * sinAlpha + offset) * vy) + (len * wy);
                    const pZ = (R2 * cosAlpha * uz) + ((R2 * sinAlpha + offset) * vz) + (len * wz);

                    // Safety check against NaN before pushing
                    if (isNaN(pX) || isNaN(pY) || isNaN(pZ)) {
                        vertices.push(0, 0, 0);
                    } else {
                        vertices.push(pX, pY, pZ);
                    }

                    // UVs
                    uvs.push(x / segments, y);
                }
            }

            // Indices
            for (let x = 0; x < segments; x++) {
                const a = x;
                const b = x + 1;
                const c = x + segments + 1;
                const d = x + segments + 2;

                indices.push(a, b, d);
                indices.push(a, d, c);
            }

            p2Geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            p2Geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            p2Geo.setIndex(indices);
            p2Geo.computeVertexNormals();

            pipe2Mesh = new THREE.Mesh(p2Geo, cutPipeMat);
            scene.add(pipe2Mesh);

            // 3. Seam Line (Red)
            const seamPoints = [];
            for (let i = 0; i <= segments; i++) {
                seamPoints.push(new THREE.Vector3(
                    vertices[i * 3],
                    vertices[i * 3 + 1],
                    vertices[i * 3 + 2]
                ));
            }
            const seamGeo = new THREE.BufferGeometry().setFromPoints(seamPoints);
            seamLineMesh = new THREE.Line(seamGeo, seamMaterial);
            scene.add(seamLineMesh);

            // Camera Target
            controls.target.set(0, 0, 0);
        }

        function getParams() {
            // Helper to safely parse inputs (Prevents NaN errors)
            const safeFloat = (val, def) => {
                if (val === "" || val === undefined) return def;
                const parsed = parseFloat(val);
                return isNaN(parsed) ? def : parsed;
            };

            const D1 = safeFloat(inputs.d1.value, 100);
            const D2 = safeFloat(inputs.d2.value, 50);
            const thickness = safeFloat(inputs.thick.value, 0);
            const gap = safeFloat(inputs.gap.value, 0);
            let angleDeg = safeFloat(inputs.angle.value, 45);
            const offset = safeFloat(inputs.offset.value, 0);
            const startAngle = safeFloat(inputs.startAngle.value, 0);
            const pd2 = safeFloat(inputs.padD2.value, 0);
            const pd1 = safeFloat(inputs.padD1.value, 0);

            if (D1 <= 0 || D2 <= 0) {
                showError("Diameters must be positive.");
                return null;
            }
            // Clamp Angle
            angleDeg = Math.max(1, Math.min(90, angleDeg));

            return {
                D1, D2, thickness, gap,
                angleDeg, angleRad: angleDeg * Math.PI / 180,
                offset, startAngleRad: startAngle * Math.PI / 180,
                padD2: pd2, padD1: pd1
            };
        }

        function showError(msg) {
            inputs.err.innerText = msg;
            inputs.err.classList.remove('hidden');
        }

        // --- DXF Logic ---

        function calculatePoints(type, params) {
            const { D1, D2, angleRad, offset, gap, thickness, startAngleRad } = params;

            const R1 = D1 / 2;
            const R2_outer = D2 / 2;
            const R2_inner = R2_outer - thickness;

            const points = [];
            const steps = 360;
            const sinTheta = Math.sin(angleRad);
            const tanTheta = Math.tan(angleRad);

            if (type === 'pipe') {
                const R1_eff = R1 + gap;
                const R2 = R2_outer;
                const circumference = 2 * Math.PI * R2;

                for (let i = 0; i <= steps; i++) {
                    const angle = (i / steps) * 2 * Math.PI;
                    const effAngle = angle + startAngleRad;
                    const x = (i / steps) * circumference;

                    let term = Math.pow(R1_eff, 2) - Math.pow(R2 * Math.sin(effAngle) + offset, 2);
                    // Force term to 0 if slightly negative (happens at cusps when D1=D2)
                    if (term < 0) {
                        if (term > -0.01) term = 0;
                        else continue;
                    }

                    const sT = Math.abs(sinTheta) < 1e-6 ? 1e-6 : sinTheta;
                    const tT = Math.abs(tanTheta) < 1e-6 ? 1e-6 : tanTheta;

                    // Same inverted sign as 3D for consistency
                    const y = (1 / sT) * Math.sqrt(term) + (R2 * Math.cos(effAngle) / tT);
                    points.push({ x, y });
                }
            } else if (type === 'hole') {
                const cosTheta = Math.cos(angleRad);
                const sT = Math.abs(sinTheta) < 1e-6 ? 1e-6 : sinTheta;

                for (let i = 0; i <= steps; i++) {
                    const alpha = (i / steps) * 2 * Math.PI;
                    const R2 = R2_inner;

                    const r2Sin = R2 * Math.sin(alpha);
                    const r2Cos = R2 * Math.cos(alpha);

                    const C1 = r2Cos * cosTheta;
                    const C2 = r2Sin + offset;

                    const term = R1 * R1 - C2 * C2;
                    if (term < 0) continue;

                    const sqrtVal = Math.sqrt(term);

                    // Distance 't' to surface
                    // FIX: Changed minus to plus to match geometry (L*sin = sqrt + u*cos)
                    // This ensures points lie exactly on the cylinder surface (x3d = sqrtVal)
                    const t = (sqrtVal + C1) / sT;

                    // 3D coordinates on Surface R1
                    const x3d = t * sinTheta - r2Cos * cosTheta;
                    const z3d = r2Sin + offset;
                    const y3d = t * cosTheta + r2Cos * sinTheta;

                    // Unwrap R1
                    let phi = Math.atan2(z3d, x3d);
                    if (phi < 0) phi += 2 * Math.PI;

                    let phiShift = phi - Math.PI;
                    if (phiShift < 0) phiShift += 2 * Math.PI;

                    const xUnroll = R1 * phiShift;
                    points.push({ x: xUnroll, y: y3d });
                }
            }

            return points;
        }

        function downloadDXF(type) {
            const params = getParams();
            if (!params) return;

            const points = calculatePoints(type, params);
            if (!points.length) {
                showError("Could not generate points. Check geometry.");
                return;
            }

            const pad = type === 'pipe' ? params.padD2 : params.padD1;

            // Normalize Y to start at 0 + padding
            const minY = Math.min(...points.map(p => p.y));
            const shiftedPoints = points.map(p => ({
                x: p.x,
                y: p.y - minY + pad
            }));

            // Header
            let dxf = "0\nSECTION\n2\nENTITIES\n";

            // Curve
            dxf += "0\nPOLYLINE\n8\n0\n66\n1\n";
            dxf += (type === 'pipe' ? "70\n1\n" : "70\n0\n"); // 1=Closed, 0=Open

            shiftedPoints.forEach(p => {
                dxf += `0\nVERTEX\n8\n0\n10\n${p.x.toFixed(4)}\n20\n${p.y.toFixed(4)}\n30\n0.0\n`;
            });

            if (type === 'pipe') {
                // Close the loop at the bottom for the paper template
                const lastX = shiftedPoints[shiftedPoints.length - 1].x;
                dxf += `0\nVERTEX\n8\n0\n10\n${lastX.toFixed(4)}\n20\n0.0\n30\n0.0\n`;
                dxf += `0\nVERTEX\n8\n0\n10\n0.0\n20\n0.0\n30\n0.0\n`;
            }

            dxf += "0\nSEQEND\n";

            // If Hole, add bounding box for reference
            if (type === 'hole') {
                const maxY = Math.max(...shiftedPoints.map(p => p.y)) + pad;
                const maxX = 2 * Math.PI * (params.D1 / 2);

                dxf += "0\nPOLYLINE\n8\n0\n66\n1\n70\n1\n";
                dxf += `0\nVERTEX\n8\n0\n10\n0.0\n20\n0.0\n30\n0.0\n`;
                dxf += `0\nVERTEX\n8\n0\n10\n${maxX.toFixed(4)}\n20\n0.0\n30\n0.0\n`;
                dxf += `0\nVERTEX\n8\n0\n10\n${maxX.toFixed(4)}\n20\n${maxY.toFixed(4)}\n30\n0.0\n`;
                dxf += `0\nVERTEX\n8\n0\n10\n0.0\n20\n${maxY.toFixed(4)}\n30\n0.0\n`;
                dxf += "0\nSEQEND\n";
            }

            dxf += "0\nENDSEC\n0\nEOF\n";

            // Download
            const blob = new Blob([dxf], { type: 'application/dxf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${type}_template.dxf`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Start
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>