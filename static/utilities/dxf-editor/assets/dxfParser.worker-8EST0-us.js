const L=(r,t)=>Math.sqrt(Math.pow(t.x-r.x,2)+Math.pow(t.y-r.y,2)),M=()=>Math.random().toString(36).substr(2,9),X=r=>{let t=1/0,s=1/0,i=-1/0,a=-1/0;if(r.length===0)return null;const e=(n,c)=>{n<t&&(t=n),n>i&&(i=n),c<s&&(s=c),c>a&&(a=c)};return r.forEach(n=>{n.type==="LINE"?(e(n.start.x,n.start.y),e(n.end.x,n.end.y)):n.type==="CIRCLE"||n.type==="ARC"?(e(n.center.x-n.radius,n.center.y-n.radius),e(n.center.x+n.radius,n.center.y+n.radius)):n.type==="LWPOLYLINE"?n.vertices.forEach(c=>e(c.x,c.y)):n.type==="INSERT"?e(n.insertionPoint.x,n.insertionPoint.y):n.type==="TEXT"&&(e(n.point.x,n.point.y),e(n.point.x+n.text.length*n.height*.6,n.point.y+n.height))}),t===1/0?null:{min:{x:t,y:s},max:{x:i,y:a},center:{x:(t+i)/2,y:(s+a)/2},width:i-t,height:a-s}};function z(r,t,s){(r.x+s.x)/2,(r.y+s.y)/2;const i=s.x-r.x,a=s.y-r.y,e=Math.sqrt(i*i+a*a);return e<1e-10?0:Math.abs((a*(t.x-r.x)-i*(t.y-r.y))/e)}function C(r,t,s,i,a=10){const e=r(t),n=r(s),c=(t+s)/2,l=r(c);if(z(e,l,n)<=i||a<=0)return[e,n];const o=C(r,t,c,i,a-1),p=C(r,c,s,i,a-1);return[...o,...p.slice(1)]}function D(r,t,s,i,a){const e=r.length-1,n=i;a<t[n]&&(a=t[n]),a>t[e+1]&&(a=t[e+1]);let c=n;for(let o=n;o<=e;o++)if(a>=t[o]&&a<t[o+1]){c=o;break}const l=[];for(let o=0;o<=n;o++){const p=c-n+o,f=s?s[p]:1;l[o]={x:r[p].x*f,y:r[p].y*f}}for(let o=1;o<=n;o++)for(let p=n;p>=o;p--){const f=c-n+p,h=(a-t[f])/(t[f+n+1-o]-t[f]),u=s?s[c-n+p-o]:1,x=s?s[c-n+p]:1;l[p].x=(1-h)*l[p-1].x+h*l[p].x,l[p].y=(1-h)*l[p-1].y+h*l[p].y,s&&(l[p].x*=(1-h)*u+h*x,l[p].y*=(1-h)*u+h*x)}const y=l[n];if(s){const o=s[c];o!==0&&(y.x/=o,y.y/=o)}return y}function v(r,t,s){const i=[],a=r+t+1;if(s)for(let e=0;e<a;e++)i.push(e);else{for(let e=0;e<=t;e++)i.push(0);for(let e=1;e<r-t;e++)i.push(e);for(let e=0;e<=t;e++)i.push(r-t)}return i}function V(r,t,s,i=3,a=.01,e=!1){if(r.length<2||r.length===2)return r;const n=t||v(r.length,i,e),c=s||null;let l=r;e&&r.length>0&&(l=[...r,...r.slice(0,i)]);const y=x=>D(l,n,c,i,x),o=n[i],p=n[n.length-i-1],f=C(y,o,p,a),h=[],u=a*.1;for(let x=0;x<f.length;x++)(h.length===0||Math.abs(h[h.length-1].x-f[x].x)>u||Math.abs(h[h.length-1].y-f[x].y)>u)&&h.push(f[x]);return h}function q(r,t,s,i,a,e=.01){const n=Math.sqrt(t.x*t.x+t.y*t.y),c=Math.atan2(t.y,t.x),l=n*s,y=f=>{const h=n*Math.cos(f),u=l*Math.sin(f),x=r.x+h*Math.cos(c)-u*Math.sin(c),E=r.y+h*Math.sin(c)+u*Math.cos(c);return{x,y:E}};let o=a-i;return o<0&&(o+=2*Math.PI),o>2*Math.PI&&(o=2*Math.PI),C(f=>y(i+f*o),0,1,e)}const $=(r,t)=>{if(Math.abs(t.x)<1e-6&&Math.abs(t.y)<1e-6&&Math.abs(t.z-1)<1e-6)return r;let i;Math.abs(t.x)<1/64&&Math.abs(t.y)<1/64?(i=N({x:-t.y,y:t.x,z:0}),i=N(S({x:0,y:1,z:0},t))):i=N(S({x:1,y:0,z:0},t));const a=N(S(t,i));return{x:r.x*i.x+r.y*a.x,y:r.x*i.y+r.y*a.y}},S=(r,t)=>({x:r.y*t.z-r.z*t.y,y:r.z*t.x-r.x*t.z,z:r.x*t.y-r.y*t.x}),N=r=>{const t=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z);return t===0?{x:0,y:0,z:1}:{x:r.x/t,y:r.y/t,z:r.z/t}};class K{constructor(){this.splineKnots=[],this.splineControlPoints=[],this.splineWeights=[],this.splineDegree=3,this.currentEntity=null,this.currentVertex=null}aciToHex(t){return t===256?void 0:t===0?"#ffffff":["#000000","#ff0000","#ffff00","#00ff00","#00ffff","#0000ff","#ff00ff","#ffffff","#808080","#c0c0c0"][t]||"#ffffff"}isValidPoint(t){return t&&typeof t.x=="number"&&typeof t.y=="number"}stripMText(t){return t.replace(/\\P/g,`
`).replace(/\\X/g,`
`).replace(/\{[^}]*;/g,"").replace(/\}/g,"").replace(/\\[QWHTfAFp].*?;/g,"").replace(/\\[LloO].*?;/g,"").replace(/\\C\d+;/g,"").replace(/\\S[^;]*;/g,"").replace(/\\~ /g," ").trim()}parse(t){const s=t.split(/\r?\n/),i=[],a={},e={};let n=null,c=null;this.currentEntity=null,this.splineControlPoints=[],this.splineKnots=[],this.splineWeights=[],this.splineDegree=3;const l=y=>{if(!this.currentEntity)return;const o=this.currentEntity;this.currentVertex&&(o.type==="POLYLINE"||o.type==="LWPOLYLINE")&&(typeof this.currentVertex.x=="number"&&typeof this.currentVertex.y=="number"&&o.vertices.push({x:this.currentVertex.x,y:this.currentVertex.y,bulge:this.currentVertex.bulge}),this.currentVertex=null);const p={id:M(),layer:o.layer||"0",color:o.color,lineStyle:o.lineStyle},f=h=>{const u=o.extrusion||{x:0,y:0,z:1};return $(h,u)};if(o.type==="LINE")this.isValidPoint(o.start)&&this.isValidPoint(o.end)&&y.push({...p,type:"LINE",start:f(o.start),end:f(o.end)});else if(o.type==="CIRCLE")this.isValidPoint(o.center)&&o.radius&&y.push({...p,type:"CIRCLE",center:f(o.center),radius:o.radius});else if(o.type==="ARC")this.isValidPoint(o.center)&&o.radius&&y.push({...p,type:"ARC",center:f(o.center),radius:o.radius,startAngle:(o.startAngle||0)*(Math.PI/180),endAngle:(o.endAngle||0)*(Math.PI/180)});else if(o.type==="LWPOLYLINE"||o.type==="POLYLINE")o.vertices&&o.vertices.length>1&&y.push({...p,type:"LWPOLYLINE",vertices:o.vertices.map(f),closed:!!o.closed});else if(o.type==="SPLINE"){const h=this.splineControlPoints.map(f),u=this.splineKnots.length>0?this.splineKnots:void 0,x=this.splineWeights.length>0?this.splineWeights:void 0,E=this.splineDegree,g=!!o.closed,I=V(h,u,x,E,.01,g);I.length>1&&y.push({...p,type:"LWPOLYLINE",vertices:I,closed:g}),this.splineKnots=[],this.splineControlPoints=[],this.splineWeights=[],this.splineDegree=3}else if(o.type==="ELLIPSE"){const h=q(f(o.center),o.majorAxis,o.ratio||1,o.startParam||0,o.endParam||2*Math.PI,.01);h.length>1&&y.push({...p,type:"LWPOLYLINE",vertices:h,closed:!1})}else if(o.type==="INSERT")o.blockName&&this.isValidPoint(o.insertionPoint)&&y.push({...p,type:"INSERT",blockName:o.blockName,insertionPoint:o.insertionPoint,scale:o.scale||{x:1,y:1},rotation:o.rotation||0});else if((o.type==="TEXT"||o.type==="MTEXT")&&this.isValidPoint(o.point)&&o.text){const h=o.type==="MTEXT"?this.stripMText(o.text):o.text;y.push({...p,type:"TEXT",point:o.point,text:h,height:o.height||10,rotation:o.rotation||0})}};for(let y=0;y<s.length-1;y+=2){const o=parseInt(s[y].trim()),p=s[y+1].trim();if(!isNaN(o)){if(o===0&&p==="SECTION"){n=null;continue}if(o===2&&n===null){n=p;continue}if(o===0&&p==="ENDSEC"){n=null;continue}if(n==="HEADER"){if(o===9){const f=p.startsWith("$")?p:"$"+p;parseInt(s[y+2].trim());const h=s[y+3].trim();e[f]=h}continue}n==="BLOCKS"?o===0&&p==="BLOCK"?c={name:"",entities:[],basePoint:{x:0,y:0}}:o===0&&p==="ENDBLK"?(c&&c.name&&(l(c.entities),this.currentEntity=null,a[c.name]=c),c=null):c&&(o===2?c.name=p:o===10?c.basePoint.x=parseFloat(p):o===20?c.basePoint.y=parseFloat(p):this.processEntityCode(o,p,c.entities,()=>l(c.entities))):n==="ENTITIES"&&this.processEntityCode(o,p,i,()=>l(i))}}return l(i),{entities:i,blocks:a,header:e}}processEntityCode(t,s,i,a){var n;if(t===0){if(s==="VERTEX")return((n=this.currentEntity)==null?void 0:n.type)!=="POLYLINE",void 0;if(s==="SEQEND"){a(),this.currentEntity=null;return}a(),this.setCurrentEntity(s);return}const e=this.currentEntity;if(e)if(t===8&&(e.layer=s),t===62&&(e.color=this.aciToHex(parseInt(s))),t===210&&(e.extrusion={...e.extrusion||{x:0,y:0,z:1},x:parseFloat(s)}),t===220&&(e.extrusion={...e.extrusion||{x:0,y:0,z:1},y:parseFloat(s)}),t===230&&(e.extrusion={...e.extrusion||{x:0,y:0,z:1},z:parseFloat(s)}),e.type==="LINE")t===10&&(e.start={...e.start,x:parseFloat(s)}),t===20&&(e.start={...e.start,y:parseFloat(s)}),t===11&&(e.end={...e.end,x:parseFloat(s)}),t===21&&(e.end={...e.end,y:parseFloat(s)});else if(e.type==="CIRCLE"||e.type==="ARC")t===10&&(e.center={...e.center,x:parseFloat(s)}),t===20&&(e.center={...e.center,y:parseFloat(s)}),t===40&&(e.radius=parseFloat(s)),e.type==="ARC"&&(t===50&&(e.startAngle=parseFloat(s)),t===51&&(e.endAngle=parseFloat(s)));else if(e.type==="LWPOLYLINE"){if(t===70&&(e.closed=(parseInt(s)&1)===1),t===10&&e.vertices.push({x:parseFloat(s),y:0}),t===20){const c=e.vertices[e.vertices.length-1];c&&(c.y=parseFloat(s))}if(t===42){const c=e.vertices[e.vertices.length-1];c&&(c.bulge=parseFloat(s))}}else e.type==="INSERT"?(t===2&&(e.blockName=s),t===10&&(e.insertionPoint={...e.insertionPoint,x:parseFloat(s)}),t===20&&(e.insertionPoint={...e.insertionPoint,y:parseFloat(s)}),t===41&&(e.scale={...e.scale,x:parseFloat(s)}),t===42&&(e.scale={...e.scale,y:parseFloat(s)}),t===50&&(e.rotation=parseFloat(s))):e.type==="TEXT"||e.type==="MTEXT"?(t===1&&(e.text=s),t===10&&(e.point={...e.point,x:parseFloat(s)}),t===20&&(e.point={...e.point,y:parseFloat(s)}),t===40&&(e.height=parseFloat(s)),t===50&&(e.rotation=parseFloat(s))):e.type==="SPLINE"?(t===10&&this.splineControlPoints.push({x:parseFloat(s),y:0}),t===20&&this.splineControlPoints.length>0&&(this.splineControlPoints[this.splineControlPoints.length-1].y=parseFloat(s)),t===40&&this.splineKnots.push(parseFloat(s)),t===41&&this.splineWeights.push(parseFloat(s)),t===71&&(this.splineDegree=parseInt(s)||3),t===70&&(e.closed=(parseInt(s)&1)===1)):e.type==="ELLIPSE"&&(t===10&&(e.center={...e.center,x:parseFloat(s)}),t===20&&(e.center={...e.center,y:parseFloat(s)}),t===11&&(e.majorAxis={...e.majorAxis,x:parseFloat(s)}),t===21&&(e.majorAxis={...e.majorAxis,y:parseFloat(s)}),t===40&&(e.ratio=parseFloat(s)),t===41&&(e.startParam=parseFloat(s)),t===42&&(e.endParam=parseFloat(s)))}setCurrentEntity(t){if(!t){this.currentEntity=null;return}const s={type:t,vertices:[],scale:{x:1,y:1},start:{},end:{},center:{},insertionPoint:{},point:{},majorAxis:{}};this.currentEntity=s}}const F={A:[[0,0,5,10,10,0],[2.5,5,7.5,5]],B:[[0,0,0,10,8,10,8,5,0,5],[0,5,8,5,8,0,0,0]],C:[[10,10,0,10,0,0,10,0]],D:[[0,0,0,10,8,8,8,2,0,0]],E:[[10,10,0,10,0,0,10,0],[0,5,8,5]],F:[[0,0,0,10,10,10],[0,5,8,5]],G:[[10,10,0,10,0,0,10,0,10,5,5,5]],H:[[0,0,0,10],[10,0,10,10],[0,5,10,5]],I:[[5,0,5,10],[0,10,10,10],[0,0,10,0]],J:[[10,10,10,2,5,0,0,2]],K:[[0,0,0,10],[10,10,0,5,10,0]],L:[[0,10,0,0,10,0]],M:[[0,0,0,10,5,5,10,10,10,0]],N:[[0,0,0,10,10,0,10,10]],O:[[0,0,0,10,10,10,10,0,0,0]],P:[[0,0,0,10,10,10,10,5,0,5]],Q:[[0,0,0,10,10,10,10,0,0,0],[5,5,10,0]],R:[[0,0,0,10,10,10,10,5,0,5],[2,5,10,0]],S:[[0,0,10,0,10,5,0,5,0,10,10,10]],T:[[5,0,5,10],[0,10,10,10]],U:[[0,10,0,0,10,0,10,10]],V:[[0,10,5,0,10,10]],W:[[0,10,2,0,5,5,8,0,10,10]],X:[[0,0,10,10],[0,10,10,0]],Y:[[0,10,5,5],[10,10,5,5],[5,5,5,0]],Z:[[0,10,10,10,0,0,10,0]],0:[[0,0,10,10],[0,10,10,0],[0,0,0,10,10,10,10,0,0,0]],1:[[2,5,5,10,5,0],[0,0,10,0]],2:[[0,10,10,10,10,5,0,0,10,0]],3:[[0,10,10,10,0,5],[0,5,10,5,10,0,0,0]],4:[[10,5,0,5,5,10],[5,10,5,0]],5:[[10,10,0,10,0,5,10,5,10,0,0,0]],6:[[10,10,0,5,0,0,10,0,10,5,0,5]],7:[[0,10,10,10,5,0]],8:[[0,5,0,10,10,10,10,5,0,5,0,0,10,0,10,5]],9:[[0,0,10,5,10,10,0,10,0,5,10,5]],"-":[[0,5,10,5]],".":[[4,0,6,0,6,2,4,2,4,0]]," ":[]},H=(r,t,s,i,a)=>{const e=[],n=s/10;let c=0;const l=i*(Math.PI/180),y=Math.cos(l),o=Math.sin(l),p=(h,u)=>{const x=h*y-u*o,E=h*o+u*y;return{x:t.x+x,y:t.y+E}},f=r.toUpperCase();for(let h=0;h<f.length;h++){const u=f[h],x=F[u]||F["?"]||[];!F[u]&&u!==" "&&[[0,0,0,10,10,10,10,0,0,0]].forEach(g=>{const I=[];for(let d=0;d<g.length;d+=2)I.push(p(g[d]*n+c,g[d+1]*n));e.push({id:M(),type:"LWPOLYLINE",layer:a,color:"BYLAYER",vertices:I,closed:!1})}),x.forEach(E=>{const g=[];for(let I=0;I<E.length;I+=2)g.push(p(E[I]*n+c,E[I+1]*n));g.length>1&&e.push({id:M(),type:"LWPOLYLINE",layer:a,color:"BYLAYER",vertices:g,closed:!1})}),c+=12*n}return e};class m{constructor(t,s=4){this.items=[],this.divided=!1,this.bounds=t,this.capacity=s}insert(t){return this.contains(t.point)?this.items.length<this.capacity&&!this.divided?(this.items.push(t),!0):(this.divided||this.subdivide(),this.nw.insert(t)||this.ne.insert(t)||this.sw.insert(t)||this.se.insert(t)):!1}query(t,s){const i=[],a=s*s;if(!this.intersectsCircle(t,s))return i;for(const e of this.items){const n=e.point.x-t.x,c=e.point.y-t.y;n*n+c*c<=a&&i.push(e)}return this.divided&&(i.push(...this.nw.query(t,s)),i.push(...this.ne.query(t,s)),i.push(...this.sw.query(t,s)),i.push(...this.se.query(t,s))),i}findNearest(t,s=1/0){let i=null,a=s*s;const e=this.query(t,s);for(const n of e){const c=n.point.x-t.x,l=n.point.y-t.y,y=c*c+l*l;y<a&&(a=y,i=n)}return i}clear(){this.items=[],this.divided=!1,this.nw=void 0,this.ne=void 0,this.sw=void 0,this.se=void 0}contains(t){return t.x>=this.bounds.x&&t.x<=this.bounds.x+this.bounds.width&&t.y>=this.bounds.y&&t.y<=this.bounds.y+this.bounds.height}intersectsCircle(t,s){const i=Math.max(this.bounds.x,Math.min(t.x,this.bounds.x+this.bounds.width)),a=Math.max(this.bounds.y,Math.min(t.y,this.bounds.y+this.bounds.height)),e=t.x-i,n=t.y-a;return e*e+n*n<=s*s}subdivide(){const t=this.bounds.x,s=this.bounds.y,i=this.bounds.width/2,a=this.bounds.height/2;this.nw=new m({x:t,y:s,width:i,height:a},this.capacity),this.ne=new m({x:t+i,y:s,width:i,height:a},this.capacity),this.sw=new m({x:t,y:s+a,width:i,height:a},this.capacity),this.se=new m({x:t+i,y:s+a,width:i,height:a},this.capacity),this.divided=!0;const e=this.items;this.items=[];for(const n of e)this.nw.insert(n)||this.ne.insert(n)||this.sw.insert(n)||this.se.insert(n)}}function A(r,t,s,i,a=4){const e=s-r||1e3,n=i-t||1e3;return new m({x:r,y:t,width:e,height:n},a)}const B=(r,t,s,i={})=>{let a=[...r];if(s.normalizeUnits&&i.$INSUNITS){const e=Z(parseInt(i.$INSUNITS));e!==1&&(a=w(a,e),Object.values(t).forEach(n=>{n.entities=w(n.entities,e),n.basePoint.x*=e,n.basePoint.y*=e}))}if(s.flattenBlocks&&(a=U(a,t)),s.vectorizeText){const e=[],n=[];a.forEach(c=>{if(c.type==="TEXT"){const l=H(c.text,c.point,c.height,c.rotation,c.layer);e.push(...l)}else n.push(c)}),a=[...n,...e]}return s.removeDuplicates&&(a=j(a)),s.mergeTolerance>0&&(a=Q(a,s.mergeTolerance)),a},U=(r,t)=>{const s=[],i=[];for(r.forEach(a=>{i.push({element:a,transform:e=>e,layer:a.layer})});i.length>0;){const a=i.pop(),e=a.element;if(e.type==="INSERT"){const n=t[e.blockName];if(n){const c=l=>k(l,e,n.basePoint);n.entities.forEach(l=>{i.push({element:l,transform:y=>c(a.transform(y)),layer:e.layer})})}}else{const n=G(e,a.transform,a.layer);s.push(n)}}return s},k=(r,t,s)=>{let i=r.x-s.x,a=r.y-s.y;if(i*=t.scale.x,a*=t.scale.y,t.rotation){const e=t.rotation*(Math.PI/180),n=Math.cos(e),c=Math.sin(e),l=i*n-a*c,y=i*c+a*n;i=l,a=y}return i+=t.insertionPoint.x,a+=t.insertionPoint.y,{x:i,y:a}},G=(r,t,s)=>{const i=JSON.parse(JSON.stringify(r));return i.id=M(),i.layer=s,i.type==="LINE"?(i.start=t(i.start),i.end=t(i.end)):i.type==="CIRCLE"||i.type==="ARC"?i.center=t(i.center):i.type==="LWPOLYLINE"?i.vertices=i.vertices.map(a=>t(a)):i.type==="INSERT"?i.insertionPoint=t(i.insertionPoint):i.type==="TEXT"&&(i.point=t(i.point)),i},j=r=>{if(r.length===0)return r;let t=1/0,s=1/0,i=-1/0,a=-1/0;if(r.forEach(y=>{y.type==="LINE"?(t=Math.min(t,y.start.x,y.end.x),i=Math.max(i,y.start.x,y.end.x),s=Math.min(s,y.start.y,y.end.y),a=Math.max(a,y.start.y,y.end.y)):y.type==="CIRCLE"||y.type==="ARC"?(t=Math.min(t,y.center.x-y.radius),i=Math.max(i,y.center.x+y.radius),s=Math.min(s,y.center.y-y.radius),a=Math.max(a,y.center.y+y.radius)):y.type==="LWPOLYLINE"&&y.vertices.forEach(o=>{t=Math.min(t,o.x),i=Math.max(i,o.x),s=Math.min(s,o.y),a=Math.max(a,o.y)})}),t===1/0)return r;const e=.001,n=A(t,s,i,a),c=new Set,l=[];return r.forEach(y=>{const o=O(y);if(c.has(o))return;const p=J(y),f=n.query(p,e);let h=!1;for(const u of f)if(u.data&&O(u.data)===o){h=!0;break}h||(c.add(o),n.insert({point:p,data:y}),l.push(y))}),l},J=r=>r.type==="LINE"?{x:(r.start.x+r.end.x)/2,y:(r.start.y+r.end.y)/2}:r.type==="CIRCLE"||r.type==="ARC"?r.center:r.type==="LWPOLYLINE"?r.vertices[0]||{x:0,y:0}:r.type==="INSERT"?r.insertionPoint:r.type==="TEXT"?r.point:{x:0,y:0},Q=(r,t)=>{const s=r.map(f=>f.type==="LINE"?{id:M(),type:"LWPOLYLINE",layer:f.layer,color:f.color,lineStyle:f.lineStyle,vertices:[f.start,f.end],closed:!1}:f.type==="LWPOLYLINE"?{...f}:null).filter(f=>f!==null);if(s.length===0)return r.filter(f=>f.type!=="LINE"&&f.type!=="LWPOLYLINE");let i=1/0,a=1/0,e=-1/0,n=-1/0;s.forEach(f=>{f.vertices.forEach(h=>{i=Math.min(i,h.x),e=Math.max(e,h.x),a=Math.min(a,h.y),n=Math.max(n,h.y)})});const c=A(i,a,e,n),l=[];s.forEach(f=>{if(!f.closed){l.push(f);const h=f.vertices[0],u=f.vertices[f.vertices.length-1];c.insert({point:h,data:{poly:f,isHead:!0}}),L(h,u)>t&&c.insert({point:u,data:{poly:f,isHead:!1}})}});let y=!0;for(;y;){y=!1,c.clear(),l.forEach(f=>{const h=f.vertices[0],u=f.vertices[f.vertices.length-1];c.insert({point:h,data:{poly:f,isHead:!0}}),L(h,u)>t&&c.insert({point:u,data:{poly:f,isHead:!1}})});for(let f=0;f<l.length;f++){const h=l[f];if(h.closed)continue;const u=h.vertices[0],x=h.vertices[h.vertices.length-1],E=c.query(u,t),g=c.query(x,t);for(const I of[...E,...g]){const{poly:d,isHead:tt}=I.data;if(d===h||d.closed)continue;const T=d.vertices[0],b=d.vertices[d.vertices.length-1];let P=!1;if(L(x,T)<t?(h.vertices=[...h.vertices,...d.vertices.slice(1)],P=!0):L(x,b)<t?(h.vertices=[...h.vertices,...d.vertices.reverse().slice(1)],P=!0):L(u,b)<t?(h.vertices=[...d.vertices,...h.vertices.slice(1)],P=!0):L(u,T)<t&&(h.vertices=[...d.vertices.reverse(),...h.vertices.slice(1)],P=!0),P){const Y=h.vertices[0],W=h.vertices[h.vertices.length-1];L(Y,W)<t&&(h.closed=!0,h.vertices.pop());const R=l.indexOf(d);R>=0&&(l.splice(R,1),f--),y=!0;break}}}}const o=s.filter(f=>f.closed);return[...r.filter(f=>f.type!=="LINE"&&f.type!=="LWPOLYLINE"),...l,...o]},O=r=>r.type==="LINE"?`L:${r.start.x.toFixed(4)},${r.start.y.toFixed(4)}-${r.end.x.toFixed(4)},${r.end.y.toFixed(4)}`:r.type==="CIRCLE"?`C:${r.center.x.toFixed(4)},${r.center.y.toFixed(4)},${r.radius.toFixed(4)}`:r.type==="ARC"?`A:${r.center.x.toFixed(4)},${r.center.y.toFixed(4)},${r.radius.toFixed(4)},${r.startAngle.toFixed(4)},${r.endAngle.toFixed(4)}`:r.id,Z=r=>({1:25.4,2:304.8,4:1,5:10,6:1e3})[r]||1,w=(r,t)=>r.map(s=>{const i=JSON.parse(JSON.stringify(s));return i.type==="LINE"?(i.start.x*=t,i.start.y*=t,i.end.x*=t,i.end.y*=t):i.type==="CIRCLE"||i.type==="ARC"?(i.center.x*=t,i.center.y*=t,i.radius*=t):i.type==="LWPOLYLINE"?i.vertices.forEach(a=>{a.x*=t,a.y*=t}):i.type==="INSERT"?(i.insertionPoint.x*=t,i.insertionPoint.y*=t):i.type==="TEXT"&&(i.point.x*=t,i.point.y*=t,i.height*=t),i}),_=new K;self.onmessage=r=>{const{type:t,content:s,options:i,metadata:a}=r.data;if(t==="PARSE")try{if(self.postMessage({type:"PROGRESS",stage:"Parsing DXF",progress:10}),s.startsWith("AutoCAD Binary DXF"))throw new Error("Binary DXF files are not supported. Please save your file as ASCII DXF (e.g., AutoCAD 2013 DXF).");const e=_.parse(s);self.postMessage({type:"PROGRESS",stage:"Normalizing geometry",progress:50});const n=i?B(e.entities,e.blocks,i,a||{}):e.entities;self.postMessage({type:"PROGRESS",stage:"Calculating extents",progress:90});const c=X(n);self.postMessage({type:"PROGRESS",stage:"Complete",progress:100});const l={type:"RESULT",elements:n,blocks:e.blocks,extents:c};self.postMessage(l)}catch(e){const n={type:"RESULT",elements:[],blocks:{},extents:null,error:e.message||"Unknown error during parsing"};self.postMessage(n)}};
