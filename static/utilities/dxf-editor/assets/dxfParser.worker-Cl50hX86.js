const L=(r,t)=>Math.sqrt(Math.pow(t.x-r.x,2)+Math.pow(t.y-r.y,2)),M=()=>Math.random().toString(36).substr(2,9),S=(r,t,s)=>{const i=s*Math.PI/180,a=Math.cos(i),e=Math.sin(i),n=r.x-t.x,c=r.y-t.y,p=n*a-c*e,h=n*e+c*a;return{x:t.x+p,y:t.y+h}},z=(r,t,s,i)=>{const a=r,e={x:r.x+t,y:r.y},n={x:r.x+t,y:r.y+s},c={x:r.x,y:r.y+s};return i===0?[a,e,n,c]:[a,S(e,a,i),S(n,a,i),S(c,a,i)]},D=r=>{let t=1/0,s=1/0,i=-1/0,a=-1/0;if(r.length===0)return null;const e=(n,c)=>{n<t&&(t=n),n>i&&(i=n),c<s&&(s=c),c>a&&(a=c)};return r.forEach(n=>{if(n.type==="LINE")e(n.start.x,n.start.y),e(n.end.x,n.end.y);else if(n.type==="CIRCLE")e(n.center.x-n.radius,n.center.y-n.radius),e(n.center.x+n.radius,n.center.y+n.radius);else if(n.type==="ARC")e(n.center.x-n.radius,n.center.y-n.radius),e(n.center.x+n.radius,n.center.y+n.radius);else if(n.type==="LWPOLYLINE")n.vertices.forEach(c=>e(c.x,c.y));else if(n.type==="INSERT")e(n.insertionPoint.x,n.insertionPoint.y);else if(n.type==="TEXT")e(n.point.x,n.point.y),e(n.point.x+n.text.length*n.height*.6,n.point.y+n.height);else if(n.type==="MTEXT"){const c=n;z(c.boxCorner,c.boxWidth,c.boxHeight,c.rotation||0).forEach(h=>e(h.x,h.y))}}),t===1/0?null:{min:{x:t,y:s},max:{x:i,y:a},center:{x:(t+i)/2,y:(s+a)/2},width:i-t,height:a-s}};function v(r,t,s){(r.x+s.x)/2,(r.y+s.y)/2;const i=s.x-r.x,a=s.y-r.y,e=Math.sqrt(i*i+a*a);return e<1e-10?0:Math.abs((a*(t.x-r.x)-i*(t.y-r.y))/e)}function T(r,t,s,i,a=10){const e=r(t),n=r(s),c=(t+s)/2,p=r(c);if(v(e,p,n)<=i||a<=0)return[e,n];const o=T(r,t,c,i,a-1),l=T(r,c,s,i,a-1);return[...o,...l.slice(1)]}function V(r,t,s,i,a){const e=r.length-1,n=i;a<t[n]&&(a=t[n]),a>t[e+1]&&(a=t[e+1]);let c=n;for(let o=n;o<=e;o++)if(a>=t[o]&&a<t[o+1]){c=o;break}const p=[];for(let o=0;o<=n;o++){const l=c-n+o,f=s?s[l]:1;p[o]={x:r[l].x*f,y:r[l].y*f}}for(let o=1;o<=n;o++)for(let l=n;l>=o;l--){const f=c-n+l,y=(a-t[f])/(t[f+n+1-o]-t[f]),u=s?s[c-n+l-o]:1,x=s?s[c-n+l]:1;p[l].x=(1-y)*p[l-1].x+y*p[l].x,p[l].y=(1-y)*p[l-1].y+y*p[l].y,s&&(p[l].x*=(1-y)*u+y*x,p[l].y*=(1-y)*u+y*x)}const h=p[n];if(s){const o=s[c];o!==0&&(h.x/=o,h.y/=o)}return h}function q(r,t,s){const i=[],a=r+t+1;if(s)for(let e=0;e<a;e++)i.push(e);else{for(let e=0;e<=t;e++)i.push(0);for(let e=1;e<r-t;e++)i.push(e);for(let e=0;e<=t;e++)i.push(r-t)}return i}function $(r,t,s,i=3,a=.01,e=!1){if(r.length<2||r.length===2)return r;const n=t||q(r.length,i,e),c=s||null;let p=r;e&&r.length>0&&(p=[...r,...r.slice(0,i)]);const h=x=>V(p,n,c,i,x),o=n[i],l=n[n.length-i-1],f=T(h,o,l,a),y=[],u=a*.1;for(let x=0;x<f.length;x++)(y.length===0||Math.abs(y[y.length-1].x-f[x].x)>u||Math.abs(y[y.length-1].y-f[x].y)>u)&&y.push(f[x]);return y}function H(r,t,s,i,a,e=.01){const n=Math.sqrt(t.x*t.x+t.y*t.y),c=Math.atan2(t.y,t.x),p=n*s,h=f=>{const y=n*Math.cos(f),u=p*Math.sin(f),x=r.x+y*Math.cos(c)-u*Math.sin(c),E=r.y+y*Math.sin(c)+u*Math.cos(c);return{x,y:E}};let o=a-i;return o<0&&(o+=2*Math.PI),o>2*Math.PI&&(o=2*Math.PI),T(f=>h(i+f*o),0,1,e)}const K=(r,t)=>{if(Math.abs(t.x)<1e-6&&Math.abs(t.y)<1e-6&&Math.abs(t.z-1)<1e-6)return r;let i;Math.abs(t.x)<1/64&&Math.abs(t.y)<1/64?(i=N({x:-t.y,y:t.x,z:0}),i=N(C({x:0,y:1,z:0},t))):i=N(C({x:1,y:0,z:0},t));const a=N(C(t,i));return{x:r.x*i.x+r.y*a.x,y:r.x*i.y+r.y*a.y}},C=(r,t)=>({x:r.y*t.z-r.z*t.y,y:r.z*t.x-r.x*t.z,z:r.x*t.y-r.y*t.x}),N=r=>{const t=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z);return t===0?{x:0,y:0,z:1}:{x:r.x/t,y:r.y/t,z:r.z/t}};class B{constructor(){this.splineKnots=[],this.splineControlPoints=[],this.splineWeights=[],this.splineDegree=3,this.currentEntity=null,this.currentVertex=null}aciToHex(t){return t===256?void 0:t===0?"#ffffff":["#000000","#ff0000","#ffff00","#00ff00","#00ffff","#0000ff","#ff00ff","#ffffff","#808080","#c0c0c0"][t]||"#ffffff"}isValidPoint(t){return t&&typeof t.x=="number"&&typeof t.y=="number"}stripMText(t){return t.replace(/\\P/g,`
`).replace(/\\X/g,`
`).replace(/\{[^}]*;/g,"").replace(/\}/g,"").replace(/\\[QWHTfAFp].*?;/g,"").replace(/\\[LloO].*?;/g,"").replace(/\\C\d+;/g,"").replace(/\\S[^;]*;/g,"").replace(/\\~ /g," ").trim()}parse(t){const s=t.split(/\r?\n/),i=[],a={},e={};let n=null,c=null;this.currentEntity=null,this.splineControlPoints=[],this.splineKnots=[],this.splineWeights=[],this.splineDegree=3;const p=h=>{if(!this.currentEntity)return;const o=this.currentEntity;this.currentVertex&&(o.type==="POLYLINE"||o.type==="LWPOLYLINE")&&(typeof this.currentVertex.x=="number"&&typeof this.currentVertex.y=="number"&&o.vertices.push({x:this.currentVertex.x,y:this.currentVertex.y,bulge:this.currentVertex.bulge}),this.currentVertex=null);const l={id:M(),layer:o.layer||"0",color:o.color,lineStyle:o.lineStyle},f=y=>{const u=o.extrusion||{x:0,y:0,z:1};return K(y,u)};if(o.type==="LINE")this.isValidPoint(o.start)&&this.isValidPoint(o.end)&&h.push({...l,type:"LINE",start:f(o.start),end:f(o.end)});else if(o.type==="CIRCLE")this.isValidPoint(o.center)&&o.radius&&h.push({...l,type:"CIRCLE",center:f(o.center),radius:o.radius});else if(o.type==="ARC")this.isValidPoint(o.center)&&o.radius&&h.push({...l,type:"ARC",center:f(o.center),radius:o.radius,startAngle:(o.startAngle||0)*(Math.PI/180),endAngle:(o.endAngle||0)*(Math.PI/180)});else if(o.type==="LWPOLYLINE"||o.type==="POLYLINE")o.vertices&&o.vertices.length>1&&h.push({...l,type:"LWPOLYLINE",vertices:o.vertices.map(f),closed:!!o.closed});else if(o.type==="SPLINE"){const y=this.splineControlPoints.map(f),u=this.splineKnots.length>0?this.splineKnots:void 0,x=this.splineWeights.length>0?this.splineWeights:void 0,E=this.splineDegree,g=!!o.closed,I=$(y,u,x,E,.01,g);I.length>1&&h.push({...l,type:"LWPOLYLINE",vertices:I,closed:g}),this.splineKnots=[],this.splineControlPoints=[],this.splineWeights=[],this.splineDegree=3}else if(o.type==="ELLIPSE"){const y=H(f(o.center),o.majorAxis,o.ratio||1,o.startParam||0,o.endParam||2*Math.PI,.01);y.length>1&&h.push({...l,type:"LWPOLYLINE",vertices:y,closed:!1})}else if(o.type==="INSERT")o.blockName&&this.isValidPoint(o.insertionPoint)&&h.push({...l,type:"INSERT",blockName:o.blockName,insertionPoint:o.insertionPoint,scale:o.scale||{x:1,y:1},rotation:o.rotation||0});else if((o.type==="TEXT"||o.type==="MTEXT")&&this.isValidPoint(o.point)&&o.text){const y=o.type==="MTEXT"?this.stripMText(o.text):o.text;h.push({...l,type:"TEXT",point:o.point,text:y,height:o.height||10,rotation:o.rotation||0})}};for(let h=0;h<s.length-1;h+=2){const o=parseInt(s[h].trim()),l=s[h+1].trim();if(!isNaN(o)){if(o===0&&l==="SECTION"){n=null;continue}if(o===2&&n===null){n=l;continue}if(o===0&&l==="ENDSEC"){n=null;continue}if(n==="HEADER"){if(o===9){const f=l.startsWith("$")?l:"$"+l;parseInt(s[h+2].trim());const y=s[h+3].trim();e[f]=y}continue}n==="BLOCKS"?o===0&&l==="BLOCK"?c={name:"",entities:[],basePoint:{x:0,y:0}}:o===0&&l==="ENDBLK"?(c&&c.name&&(p(c.entities),this.currentEntity=null,a[c.name]=c),c=null):c&&(o===2?c.name=l:o===10?c.basePoint.x=parseFloat(l):o===20?c.basePoint.y=parseFloat(l):this.processEntityCode(o,l,c.entities,()=>p(c.entities))):n==="ENTITIES"&&this.processEntityCode(o,l,i,()=>p(i))}}return p(i),{entities:i,blocks:a,header:e}}processEntityCode(t,s,i,a){var n;if(t===0){if(s==="VERTEX")return((n=this.currentEntity)==null?void 0:n.type)!=="POLYLINE",void 0;if(s==="SEQEND"){a(),this.currentEntity=null;return}a(),this.setCurrentEntity(s);return}const e=this.currentEntity;if(e)if(t===8&&(e.layer=s),t===62&&(e.color=this.aciToHex(parseInt(s))),t===210&&(e.extrusion={...e.extrusion||{x:0,y:0,z:1},x:parseFloat(s)}),t===220&&(e.extrusion={...e.extrusion||{x:0,y:0,z:1},y:parseFloat(s)}),t===230&&(e.extrusion={...e.extrusion||{x:0,y:0,z:1},z:parseFloat(s)}),e.type==="LINE")t===10&&(e.start={...e.start,x:parseFloat(s)}),t===20&&(e.start={...e.start,y:parseFloat(s)}),t===11&&(e.end={...e.end,x:parseFloat(s)}),t===21&&(e.end={...e.end,y:parseFloat(s)});else if(e.type==="CIRCLE"||e.type==="ARC")t===10&&(e.center={...e.center,x:parseFloat(s)}),t===20&&(e.center={...e.center,y:parseFloat(s)}),t===40&&(e.radius=parseFloat(s)),e.type==="ARC"&&(t===50&&(e.startAngle=parseFloat(s)),t===51&&(e.endAngle=parseFloat(s)));else if(e.type==="LWPOLYLINE"){if(t===70&&(e.closed=(parseInt(s)&1)===1),t===10&&e.vertices.push({x:parseFloat(s),y:0}),t===20){const c=e.vertices[e.vertices.length-1];c&&(c.y=parseFloat(s))}if(t===42){const c=e.vertices[e.vertices.length-1];c&&(c.bulge=parseFloat(s))}}else e.type==="INSERT"?(t===2&&(e.blockName=s),t===10&&(e.insertionPoint={...e.insertionPoint,x:parseFloat(s)}),t===20&&(e.insertionPoint={...e.insertionPoint,y:parseFloat(s)}),t===41&&(e.scale={...e.scale,x:parseFloat(s)}),t===42&&(e.scale={...e.scale,y:parseFloat(s)}),t===50&&(e.rotation=parseFloat(s))):e.type==="TEXT"||e.type==="MTEXT"?(t===1&&(e.text=s),t===10&&(e.point={...e.point,x:parseFloat(s)}),t===20&&(e.point={...e.point,y:parseFloat(s)}),t===40&&(e.height=parseFloat(s)),t===50&&(e.rotation=parseFloat(s))):e.type==="SPLINE"?(t===10&&this.splineControlPoints.push({x:parseFloat(s),y:0}),t===20&&this.splineControlPoints.length>0&&(this.splineControlPoints[this.splineControlPoints.length-1].y=parseFloat(s)),t===40&&this.splineKnots.push(parseFloat(s)),t===41&&this.splineWeights.push(parseFloat(s)),t===71&&(this.splineDegree=parseInt(s)||3),t===70&&(e.closed=(parseInt(s)&1)===1)):e.type==="ELLIPSE"&&(t===10&&(e.center={...e.center,x:parseFloat(s)}),t===20&&(e.center={...e.center,y:parseFloat(s)}),t===11&&(e.majorAxis={...e.majorAxis,x:parseFloat(s)}),t===21&&(e.majorAxis={...e.majorAxis,y:parseFloat(s)}),t===40&&(e.ratio=parseFloat(s)),t===41&&(e.startParam=parseFloat(s)),t===42&&(e.endParam=parseFloat(s)))}setCurrentEntity(t){if(!t){this.currentEntity=null;return}const s={type:t,vertices:[],scale:{x:1,y:1},start:{},end:{},center:{},insertionPoint:{},point:{},majorAxis:{}};this.currentEntity=s}}const F={A:[[0,0,5,10,10,0],[2.5,5,7.5,5]],B:[[0,0,0,10,8,10,8,5,0,5],[0,5,8,5,8,0,0,0]],C:[[10,10,0,10,0,0,10,0]],D:[[0,0,0,10,8,8,8,2,0,0]],E:[[10,10,0,10,0,0,10,0],[0,5,8,5]],F:[[0,0,0,10,10,10],[0,5,8,5]],G:[[10,10,0,10,0,0,10,0,10,5,5,5]],H:[[0,0,0,10],[10,0,10,10],[0,5,10,5]],I:[[5,0,5,10],[0,10,10,10],[0,0,10,0]],J:[[10,10,10,2,5,0,0,2]],K:[[0,0,0,10],[10,10,0,5,10,0]],L:[[0,10,0,0,10,0]],M:[[0,0,0,10,5,5,10,10,10,0]],N:[[0,0,0,10,10,0,10,10]],O:[[0,0,0,10,10,10,10,0,0,0]],P:[[0,0,0,10,10,10,10,5,0,5]],Q:[[0,0,0,10,10,10,10,0,0,0],[5,5,10,0]],R:[[0,0,0,10,10,10,10,5,0,5],[2,5,10,0]],S:[[0,0,10,0,10,5,0,5,0,10,10,10]],T:[[5,0,5,10],[0,10,10,10]],U:[[0,10,0,0,10,0,10,10]],V:[[0,10,5,0,10,10]],W:[[0,10,2,0,5,5,8,0,10,10]],X:[[0,0,10,10],[0,10,10,0]],Y:[[0,10,5,5],[10,10,5,5],[5,5,5,0]],Z:[[0,10,10,10,0,0,10,0]],0:[[0,0,10,10],[0,10,10,0],[0,0,0,10,10,10,10,0,0,0]],1:[[2,5,5,10,5,0],[0,0,10,0]],2:[[0,10,10,10,10,5,0,0,10,0]],3:[[0,10,10,10,0,5],[0,5,10,5,10,0,0,0]],4:[[10,5,0,5,5,10],[5,10,5,0]],5:[[10,10,0,10,0,5,10,5,10,0,0,0]],6:[[10,10,0,5,0,0,10,0,10,5,0,5]],7:[[0,10,10,10,5,0]],8:[[0,5,0,10,10,10,10,5,0,5,0,0,10,0,10,5]],9:[[0,0,10,5,10,10,0,10,0,5,10,5]],"-":[[0,5,10,5]],".":[[4,0,6,0,6,2,4,2,4,0]]," ":[]},U=(r,t,s,i,a)=>{const e=[],n=s/10;let c=0;const p=i*(Math.PI/180),h=Math.cos(p),o=Math.sin(p),l=(y,u)=>{const x=y*h-u*o,E=y*o+u*h;return{x:t.x+x,y:t.y+E}},f=r.toUpperCase();for(let y=0;y<f.length;y++){const u=f[y],x=F[u]||F["?"]||[];!F[u]&&u!==" "&&[[0,0,0,10,10,10,10,0,0,0]].forEach(g=>{const I=[];for(let d=0;d<g.length;d+=2)I.push(l(g[d]*n+c,g[d+1]*n));e.push({id:M(),type:"LWPOLYLINE",layer:a,color:"BYLAYER",vertices:I,closed:!1})}),x.forEach(E=>{const g=[];for(let I=0;I<E.length;I+=2)g.push(l(E[I]*n+c,E[I+1]*n));g.length>1&&e.push({id:M(),type:"LWPOLYLINE",layer:a,color:"BYLAYER",vertices:g,closed:!1})}),c+=12*n}return e};class m{constructor(t,s=4){this.items=[],this.divided=!1,this.bounds=t,this.capacity=s}insert(t){return this.contains(t.point)?this.items.length<this.capacity&&!this.divided?(this.items.push(t),!0):(this.divided||this.subdivide(),this.nw.insert(t)||this.ne.insert(t)||this.sw.insert(t)||this.se.insert(t)):!1}query(t,s){const i=[],a=s*s;if(!this.intersectsCircle(t,s))return i;for(const e of this.items){const n=e.point.x-t.x,c=e.point.y-t.y;n*n+c*c<=a&&i.push(e)}return this.divided&&(i.push(...this.nw.query(t,s)),i.push(...this.ne.query(t,s)),i.push(...this.sw.query(t,s)),i.push(...this.se.query(t,s))),i}findNearest(t,s=1/0){let i=null,a=s*s;const e=this.query(t,s);for(const n of e){const c=n.point.x-t.x,p=n.point.y-t.y,h=c*c+p*p;h<a&&(a=h,i=n)}return i}clear(){this.items=[],this.divided=!1,this.nw=void 0,this.ne=void 0,this.sw=void 0,this.se=void 0}contains(t){return t.x>=this.bounds.x&&t.x<=this.bounds.x+this.bounds.width&&t.y>=this.bounds.y&&t.y<=this.bounds.y+this.bounds.height}intersectsCircle(t,s){const i=Math.max(this.bounds.x,Math.min(t.x,this.bounds.x+this.bounds.width)),a=Math.max(this.bounds.y,Math.min(t.y,this.bounds.y+this.bounds.height)),e=t.x-i,n=t.y-a;return e*e+n*n<=s*s}subdivide(){const t=this.bounds.x,s=this.bounds.y,i=this.bounds.width/2,a=this.bounds.height/2;this.nw=new m({x:t,y:s,width:i,height:a},this.capacity),this.ne=new m({x:t+i,y:s,width:i,height:a},this.capacity),this.sw=new m({x:t,y:s+a,width:i,height:a},this.capacity),this.se=new m({x:t+i,y:s+a,width:i,height:a},this.capacity),this.divided=!0;const e=this.items;this.items=[];for(const n of e)this.nw.insert(n)||this.ne.insert(n)||this.sw.insert(n)||this.se.insert(n)}}function Y(r,t,s,i,a=4){const e=s-r||1e3,n=i-t||1e3;return new m({x:r,y:t,width:e,height:n},a)}const k=(r,t,s,i={})=>{let a=[...r];if(s.normalizeUnits&&i.$INSUNITS){const e=tt(parseInt(i.$INSUNITS));e!==1&&(a=A(a,e),Object.values(t).forEach(n=>{n.entities=A(n.entities,e),n.basePoint.x*=e,n.basePoint.y*=e}))}if(s.flattenBlocks&&(a=G(a,t)),s.vectorizeText){const e=[],n=[];a.forEach(c=>{if(c.type==="TEXT"){const p=U(c.text,c.point,c.height,c.rotation,c.layer);e.push(...p)}else n.push(c)}),a=[...n,...e]}return s.removeDuplicates&&(a=Q(a)),s.mergeTolerance>0&&(a=_(a,s.mergeTolerance)),a},G=(r,t)=>{const s=[],i=[];for(r.forEach(a=>{i.push({element:a,transform:e=>e,layer:a.layer})});i.length>0;){const a=i.pop(),e=a.element;if(e.type==="INSERT"){const n=t[e.blockName];if(n){const c=p=>j(p,e,n.basePoint);n.entities.forEach(p=>{i.push({element:p,transform:h=>c(a.transform(h)),layer:e.layer})})}}else{const n=J(e,a.transform,a.layer);s.push(n)}}return s},j=(r,t,s)=>{let i=r.x-s.x,a=r.y-s.y;if(i*=t.scale.x,a*=t.scale.y,t.rotation){const e=t.rotation*(Math.PI/180),n=Math.cos(e),c=Math.sin(e),p=i*n-a*c,h=i*c+a*n;i=p,a=h}return i+=t.insertionPoint.x,a+=t.insertionPoint.y,{x:i,y:a}},J=(r,t,s)=>{const i=JSON.parse(JSON.stringify(r));return i.id=M(),i.layer=s,i.type==="LINE"?(i.start=t(i.start),i.end=t(i.end)):i.type==="CIRCLE"||i.type==="ARC"?i.center=t(i.center):i.type==="LWPOLYLINE"?i.vertices=i.vertices.map(a=>t(a)):i.type==="INSERT"?i.insertionPoint=t(i.insertionPoint):i.type==="TEXT"&&(i.point=t(i.point)),i},Q=r=>{if(r.length===0)return r;let t=1/0,s=1/0,i=-1/0,a=-1/0;if(r.forEach(h=>{h.type==="LINE"?(t=Math.min(t,h.start.x,h.end.x),i=Math.max(i,h.start.x,h.end.x),s=Math.min(s,h.start.y,h.end.y),a=Math.max(a,h.start.y,h.end.y)):h.type==="CIRCLE"||h.type==="ARC"?(t=Math.min(t,h.center.x-h.radius),i=Math.max(i,h.center.x+h.radius),s=Math.min(s,h.center.y-h.radius),a=Math.max(a,h.center.y+h.radius)):h.type==="LWPOLYLINE"&&h.vertices.forEach(o=>{t=Math.min(t,o.x),i=Math.max(i,o.x),s=Math.min(s,o.y),a=Math.max(a,o.y)})}),t===1/0)return r;const e=.001,n=Y(t,s,i,a),c=new Set,p=[];return r.forEach(h=>{const o=w(h);if(c.has(o))return;const l=Z(h),f=n.query(l,e);let y=!1;for(const u of f)if(u.data&&w(u.data)===o){y=!0;break}y||(c.add(o),n.insert({point:l,data:h}),p.push(h))}),p},Z=r=>r.type==="LINE"?{x:(r.start.x+r.end.x)/2,y:(r.start.y+r.end.y)/2}:r.type==="CIRCLE"||r.type==="ARC"?r.center:r.type==="LWPOLYLINE"?r.vertices[0]||{x:0,y:0}:r.type==="INSERT"?r.insertionPoint:r.type==="TEXT"?r.point:{x:0,y:0},_=(r,t)=>{const s=r.map(f=>f.type==="LINE"?{id:M(),type:"LWPOLYLINE",layer:f.layer,color:f.color,lineStyle:f.lineStyle,vertices:[f.start,f.end],closed:!1}:f.type==="LWPOLYLINE"?{...f}:null).filter(f=>f!==null);if(s.length===0)return r.filter(f=>f.type!=="LINE"&&f.type!=="LWPOLYLINE");let i=1/0,a=1/0,e=-1/0,n=-1/0;s.forEach(f=>{f.vertices.forEach(y=>{i=Math.min(i,y.x),e=Math.max(e,y.x),a=Math.min(a,y.y),n=Math.max(n,y.y)})});const c=Y(i,a,e,n),p=[];s.forEach(f=>{if(!f.closed){p.push(f);const y=f.vertices[0],u=f.vertices[f.vertices.length-1];c.insert({point:y,data:{poly:f,isHead:!0}}),L(y,u)>t&&c.insert({point:u,data:{poly:f,isHead:!1}})}});let h=!0;for(;h;){h=!1,c.clear(),p.forEach(f=>{const y=f.vertices[0],u=f.vertices[f.vertices.length-1];c.insert({point:y,data:{poly:f,isHead:!0}}),L(y,u)>t&&c.insert({point:u,data:{poly:f,isHead:!1}})});for(let f=0;f<p.length;f++){const y=p[f];if(y.closed)continue;const u=y.vertices[0],x=y.vertices[y.vertices.length-1],E=c.query(u,t),g=c.query(x,t);for(const I of[...E,...g]){const{poly:d,isHead:st}=I.data;if(d===y||d.closed)continue;const b=d.vertices[0],R=d.vertices[d.vertices.length-1];let P=!1;if(L(x,b)<t?(y.vertices=[...y.vertices,...d.vertices.slice(1)],P=!0):L(x,R)<t?(y.vertices=[...y.vertices,...d.vertices.reverse().slice(1)],P=!0):L(u,R)<t?(y.vertices=[...d.vertices,...y.vertices.slice(1)],P=!0):L(u,b)<t&&(y.vertices=[...d.vertices.reverse(),...y.vertices.slice(1)],P=!0),P){const W=y.vertices[0],X=y.vertices[y.vertices.length-1];L(W,X)<t&&(y.closed=!0,y.vertices.pop());const O=p.indexOf(d);O>=0&&(p.splice(O,1),f--),h=!0;break}}}}const o=s.filter(f=>f.closed);return[...r.filter(f=>f.type!=="LINE"&&f.type!=="LWPOLYLINE"),...p,...o]},w=r=>r.type==="LINE"?`L:${r.start.x.toFixed(4)},${r.start.y.toFixed(4)}-${r.end.x.toFixed(4)},${r.end.y.toFixed(4)}`:r.type==="CIRCLE"?`C:${r.center.x.toFixed(4)},${r.center.y.toFixed(4)},${r.radius.toFixed(4)}`:r.type==="ARC"?`A:${r.center.x.toFixed(4)},${r.center.y.toFixed(4)},${r.radius.toFixed(4)},${r.startAngle.toFixed(4)},${r.endAngle.toFixed(4)}`:r.id,tt=r=>({1:25.4,2:304.8,4:1,5:10,6:1e3})[r]||1,A=(r,t)=>r.map(s=>{const i=JSON.parse(JSON.stringify(s));return i.type==="LINE"?(i.start.x*=t,i.start.y*=t,i.end.x*=t,i.end.y*=t):i.type==="CIRCLE"||i.type==="ARC"?(i.center.x*=t,i.center.y*=t,i.radius*=t):i.type==="LWPOLYLINE"?i.vertices.forEach(a=>{a.x*=t,a.y*=t}):i.type==="INSERT"?(i.insertionPoint.x*=t,i.insertionPoint.y*=t):i.type==="TEXT"&&(i.point.x*=t,i.point.y*=t,i.height*=t),i}),et=new B;self.onmessage=r=>{const{type:t,content:s,options:i,metadata:a}=r.data;if(t==="PARSE")try{if(self.postMessage({type:"PROGRESS",stage:"Parsing DXF",progress:10}),s.startsWith("AutoCAD Binary DXF"))throw new Error("Binary DXF files are not supported. Please save your file as ASCII DXF (e.g., AutoCAD 2013 DXF).");const e=et.parse(s);self.postMessage({type:"PROGRESS",stage:"Normalizing geometry",progress:50});const n=i?k(e.entities,e.blocks,i,a||{}):e.entities;self.postMessage({type:"PROGRESS",stage:"Calculating extents",progress:90});const c=D(n);self.postMessage({type:"PROGRESS",stage:"Complete",progress:100});const p={type:"RESULT",elements:n,blocks:e.blocks,extents:c};self.postMessage(p)}catch(e){const n={type:"RESULT",elements:[],blocks:{},extents:null,error:e.message||"Unknown error during parsing"};self.postMessage(n)}};
